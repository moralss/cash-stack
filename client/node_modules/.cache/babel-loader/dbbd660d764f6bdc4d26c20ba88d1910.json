{"ast":null,"code":"/**\n * Globalize v1.4.2\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2019-03-07T13:47Z\n */\n\n/*!\n * Globalize v1.4.2 2019-03-07T13:47Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  // UMD returnExports\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"cldr\", \"../globalize\", \"cldr/event\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"cldrjs\"), require(\"../globalize\"));\n  } else {\n    // Extend global\n    factory(root.Cldr, root.Globalize);\n  }\n})(this, function (Cldr, Globalize) {\n  var alwaysArray = Globalize._alwaysArray,\n      createError = Globalize._createError,\n      isPlainObject = Globalize._isPlainObject,\n      runtimeBind = Globalize._runtimeBind,\n      validateDefaultLocale = Globalize._validateDefaultLocale,\n      validate = Globalize._validate,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n  var MessageFormat;\n  /* jshint ignore:start */\n\n  MessageFormat = function () {\n    MessageFormat._parse = function () {\n      /*\n       * Generated by PEG.js 0.8.0.\n       *\n       * http://pegjs.majda.cz/\n       */\n      function peg$subclass(child, parent) {\n        function ctor() {\n          this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n\n      function SyntaxError(message, expected, found, offset, line, column) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.offset = offset;\n        this.line = line;\n        this.column = column;\n        this.name = \"SyntaxError\";\n      }\n\n      peg$subclass(SyntaxError, Error);\n\n      function parse(input) {\n        var options = arguments.length > 1 ? arguments[1] : {},\n            peg$FAILED = {},\n            peg$startRuleFunctions = {\n          start: peg$parsestart\n        },\n            peg$startRuleFunction = peg$parsestart,\n            peg$c0 = [],\n            peg$c1 = function (st) {\n          return {\n            type: 'messageFormatPattern',\n            statements: st\n          };\n        },\n            peg$c2 = peg$FAILED,\n            peg$c3 = \"{\",\n            peg$c4 = {\n          type: \"literal\",\n          value: \"{\",\n          description: \"\\\"{\\\"\"\n        },\n            peg$c5 = null,\n            peg$c6 = \",\",\n            peg$c7 = {\n          type: \"literal\",\n          value: \",\",\n          description: \"\\\",\\\"\"\n        },\n            peg$c8 = \"}\",\n            peg$c9 = {\n          type: \"literal\",\n          value: \"}\",\n          description: \"\\\"}\\\"\"\n        },\n            peg$c10 = function (argIdx, efmt) {\n          var res = {\n            type: \"messageFormatElement\",\n            argumentIndex: argIdx\n          };\n\n          if (efmt && efmt.length) {\n            res.elementFormat = efmt[1];\n          } else {\n            res.output = true;\n          }\n\n          return res;\n        },\n            peg$c11 = \"plural\",\n            peg$c12 = {\n          type: \"literal\",\n          value: \"plural\",\n          description: \"\\\"plural\\\"\"\n        },\n            peg$c13 = function (t, s) {\n          return {\n            type: \"elementFormat\",\n            key: t,\n            val: s\n          };\n        },\n            peg$c14 = \"selectordinal\",\n            peg$c15 = {\n          type: \"literal\",\n          value: \"selectordinal\",\n          description: \"\\\"selectordinal\\\"\"\n        },\n            peg$c16 = \"select\",\n            peg$c17 = {\n          type: \"literal\",\n          value: \"select\",\n          description: \"\\\"select\\\"\"\n        },\n            peg$c18 = function (t, p) {\n          return {\n            type: \"elementFormat\",\n            key: t,\n            val: p\n          };\n        },\n            peg$c19 = function (op, pf) {\n          return {\n            type: \"pluralFormatPattern\",\n            pluralForms: pf,\n            offset: op || 0\n          };\n        },\n            peg$c20 = \"offset\",\n            peg$c21 = {\n          type: \"literal\",\n          value: \"offset\",\n          description: \"\\\"offset\\\"\"\n        },\n            peg$c22 = \":\",\n            peg$c23 = {\n          type: \"literal\",\n          value: \":\",\n          description: \"\\\":\\\"\"\n        },\n            peg$c24 = function (d) {\n          return d;\n        },\n            peg$c25 = function (k, mfp) {\n          return {\n            key: k,\n            val: mfp\n          };\n        },\n            peg$c26 = function (i) {\n          return i;\n        },\n            peg$c27 = \"=\",\n            peg$c28 = {\n          type: \"literal\",\n          value: \"=\",\n          description: \"\\\"=\\\"\"\n        },\n            peg$c29 = function (pf) {\n          return {\n            type: \"selectFormatPattern\",\n            pluralForms: pf\n          };\n        },\n            peg$c30 = function (p) {\n          return p;\n        },\n            peg$c31 = \"#\",\n            peg$c32 = {\n          type: \"literal\",\n          value: \"#\",\n          description: \"\\\"#\\\"\"\n        },\n            peg$c33 = function () {\n          return {\n            type: 'octothorpe'\n          };\n        },\n            peg$c34 = function (s) {\n          return {\n            type: \"string\",\n            val: s.join('')\n          };\n        },\n            peg$c35 = {\n          type: \"other\",\n          description: \"identifier\"\n        },\n            peg$c36 = /^[0-9a-zA-Z$_]/,\n            peg$c37 = {\n          type: \"class\",\n          value: \"[0-9a-zA-Z$_]\",\n          description: \"[0-9a-zA-Z$_]\"\n        },\n            peg$c38 = /^[^ \\t\\n\\r,.+={}]/,\n            peg$c39 = {\n          type: \"class\",\n          value: \"[^ \\\\t\\\\n\\\\r,.+={}]\",\n          description: \"[^ \\\\t\\\\n\\\\r,.+={}]\"\n        },\n            peg$c40 = function (s) {\n          return s;\n        },\n            peg$c41 = function (chars) {\n          return chars.join('');\n        },\n            peg$c42 = /^[^{}#\\\\\\0-\\x1F \\t\\n\\r]/,\n            peg$c43 = {\n          type: \"class\",\n          value: \"[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\",\n          description: \"[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]\"\n        },\n            peg$c44 = function (x) {\n          return x;\n        },\n            peg$c45 = \"\\\\\\\\\",\n            peg$c46 = {\n          type: \"literal\",\n          value: \"\\\\\\\\\",\n          description: \"\\\"\\\\\\\\\\\\\\\\\\\"\"\n        },\n            peg$c47 = function () {\n          return \"\\\\\";\n        },\n            peg$c48 = \"\\\\#\",\n            peg$c49 = {\n          type: \"literal\",\n          value: \"\\\\#\",\n          description: \"\\\"\\\\\\\\#\\\"\"\n        },\n            peg$c50 = function () {\n          return \"#\";\n        },\n            peg$c51 = \"\\\\{\",\n            peg$c52 = {\n          type: \"literal\",\n          value: \"\\\\{\",\n          description: \"\\\"\\\\\\\\{\\\"\"\n        },\n            peg$c53 = function () {\n          return \"\\u007B\";\n        },\n            peg$c54 = \"\\\\}\",\n            peg$c55 = {\n          type: \"literal\",\n          value: \"\\\\}\",\n          description: \"\\\"\\\\\\\\}\\\"\"\n        },\n            peg$c56 = function () {\n          return \"\\u007D\";\n        },\n            peg$c57 = \"\\\\u\",\n            peg$c58 = {\n          type: \"literal\",\n          value: \"\\\\u\",\n          description: \"\\\"\\\\\\\\u\\\"\"\n        },\n            peg$c59 = function (h1, h2, h3, h4) {\n          return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));\n        },\n            peg$c60 = /^[0-9]/,\n            peg$c61 = {\n          type: \"class\",\n          value: \"[0-9]\",\n          description: \"[0-9]\"\n        },\n            peg$c62 = function (ds) {\n          //the number might start with 0 but must not be interpreted as an octal number\n          //Hence, the base is passed to parseInt explicitely\n          return parseInt(ds.join(''), 10);\n        },\n            peg$c63 = /^[0-9a-fA-F]/,\n            peg$c64 = {\n          type: \"class\",\n          value: \"[0-9a-fA-F]\",\n          description: \"[0-9a-fA-F]\"\n        },\n            peg$c65 = {\n          type: \"other\",\n          description: \"whitespace\"\n        },\n            peg$c66 = function (w) {\n          return w.join('');\n        },\n            peg$c67 = /^[ \\t\\n\\r]/,\n            peg$c68 = {\n          type: \"class\",\n          value: \"[ \\\\t\\\\n\\\\r]\",\n          description: \"[ \\\\t\\\\n\\\\r]\"\n        },\n            peg$currPos = 0,\n            peg$reportedPos = 0,\n            peg$cachedPos = 0,\n            peg$cachedPosDetails = {\n          line: 1,\n          column: 1,\n          seenCR: false\n        },\n            peg$maxFailPos = 0,\n            peg$maxFailExpected = [],\n            peg$silentFails = 0,\n            peg$result;\n\n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n\n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n\n        function text() {\n          return input.substring(peg$reportedPos, peg$currPos);\n        }\n\n        function offset() {\n          return peg$reportedPos;\n        }\n\n        function line() {\n          return peg$computePosDetails(peg$reportedPos).line;\n        }\n\n        function column() {\n          return peg$computePosDetails(peg$reportedPos).column;\n        }\n\n        function expected(description) {\n          throw peg$buildException(null, [{\n            type: \"other\",\n            description: description\n          }], peg$reportedPos);\n        }\n\n        function error(message) {\n          throw peg$buildException(message, null, peg$reportedPos);\n        }\n\n        function peg$computePosDetails(pos) {\n          function advance(details, startPos, endPos) {\n            var p, ch;\n\n            for (p = startPos; p < endPos; p++) {\n              ch = input.charAt(p);\n\n              if (ch === \"\\n\") {\n                if (!details.seenCR) {\n                  details.line++;\n                }\n\n                details.column = 1;\n                details.seenCR = false;\n              } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n                details.line++;\n                details.column = 1;\n                details.seenCR = true;\n              } else {\n                details.column++;\n                details.seenCR = false;\n              }\n            }\n          }\n\n          if (peg$cachedPos !== pos) {\n            if (peg$cachedPos > pos) {\n              peg$cachedPos = 0;\n              peg$cachedPosDetails = {\n                line: 1,\n                column: 1,\n                seenCR: false\n              };\n            }\n\n            advance(peg$cachedPosDetails, peg$cachedPos, pos);\n            peg$cachedPos = pos;\n          }\n\n          return peg$cachedPosDetails;\n        }\n\n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) {\n            return;\n          }\n\n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n\n          peg$maxFailExpected.push(expected);\n        }\n\n        function peg$buildException(message, expected, pos) {\n          function cleanupExpected(expected) {\n            var i = 1;\n            expected.sort(function (a, b) {\n              if (a.description < b.description) {\n                return -1;\n              } else if (a.description > b.description) {\n                return 1;\n              } else {\n                return 0;\n              }\n            });\n\n            while (i < expected.length) {\n              if (expected[i - 1] === expected[i]) {\n                expected.splice(i, 1);\n              } else {\n                i++;\n              }\n            }\n          }\n\n          function buildMessage(expected, found) {\n            function stringEscape(s) {\n              function hex(ch) {\n                return ch.charCodeAt(0).toString(16).toUpperCase();\n              }\n\n              return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\x08/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function (ch) {\n                return '\\\\x0' + hex(ch);\n              }).replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function (ch) {\n                return '\\\\x' + hex(ch);\n              }).replace(/[\\u0180-\\u0FFF]/g, function (ch) {\n                return '\\\\u0' + hex(ch);\n              }).replace(/[\\u1080-\\uFFFF]/g, function (ch) {\n                return '\\\\u' + hex(ch);\n              });\n            }\n\n            var expectedDescs = new Array(expected.length),\n                expectedDesc,\n                foundDesc,\n                i;\n\n            for (i = 0; i < expected.length; i++) {\n              expectedDescs[i] = expected[i].description;\n            }\n\n            expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(\", \") + \" or \" + expectedDescs[expected.length - 1] : expectedDescs[0];\n            foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n            return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n          }\n\n          var posDetails = peg$computePosDetails(pos),\n              found = pos < input.length ? input.charAt(pos) : null;\n\n          if (expected !== null) {\n            cleanupExpected(expected);\n          }\n\n          return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);\n        }\n\n        function peg$parsestart() {\n          var s0;\n          s0 = peg$parsemessageFormatPattern();\n          return s0;\n        }\n\n        function peg$parsemessageFormatPattern() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsemessageFormatElement();\n\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsestring();\n\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseoctothorpe();\n            }\n          }\n\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsemessageFormatElement();\n\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsestring();\n\n              if (s2 === peg$FAILED) {\n                s2 = peg$parseoctothorpe();\n              }\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c1(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsemessageFormatElement() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s1 = peg$c3;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c4);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseid();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s5 = peg$c6;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c7);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseelementFormat();\n\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$c2;\n                }\n\n                if (s4 === peg$FAILED) {\n                  s4 = peg$c5;\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s6 = peg$c8;\n                      peg$currPos++;\n                    } else {\n                      s6 = peg$FAILED;\n\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$c9);\n                      }\n                    }\n\n                    if (s6 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c10(s3, s4);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parseelementFormat() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c11) {\n              s2 = peg$c11;\n              peg$currPos += 6;\n            } else {\n              s2 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c12);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s4 = peg$c6;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c7);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsepluralFormatPattern();\n\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n\n                      if (s7 !== peg$FAILED) {\n                        peg$reportedPos = s0;\n                        s1 = peg$c13(s2, s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 13) === peg$c14) {\n                s2 = peg$c14;\n                peg$currPos += 13;\n              } else {\n                s2 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c15);\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n\n                if (s3 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s4 = peg$c6;\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$c7);\n                    }\n                  }\n\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parse_();\n\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parsepluralFormatPattern();\n\n                      if (s6 !== peg$FAILED) {\n                        s7 = peg$parse_();\n\n                        if (s7 !== peg$FAILED) {\n                          peg$reportedPos = s0;\n                          s1 = peg$c13(s2, s6);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parse_();\n\n              if (s1 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 6) === peg$c16) {\n                  s2 = peg$c16;\n                  peg$currPos += 6;\n                } else {\n                  s2 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c17);\n                  }\n                }\n\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parse_();\n\n                  if (s3 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 44) {\n                      s4 = peg$c6;\n                      peg$currPos++;\n                    } else {\n                      s4 = peg$FAILED;\n\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$c7);\n                      }\n                    }\n\n                    if (s4 !== peg$FAILED) {\n                      s5 = peg$parse_();\n\n                      if (s5 !== peg$FAILED) {\n                        s6 = peg$parseselectFormatPattern();\n\n                        if (s6 !== peg$FAILED) {\n                          s7 = peg$parse_();\n\n                          if (s7 !== peg$FAILED) {\n                            peg$reportedPos = s0;\n                            s1 = peg$c13(s2, s6);\n                            s0 = s1;\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c2;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parse_();\n\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parseid();\n\n                  if (s2 !== peg$FAILED) {\n                    s3 = [];\n                    s4 = peg$parseargStylePattern();\n\n                    while (s4 !== peg$FAILED) {\n                      s3.push(s4);\n                      s4 = peg$parseargStylePattern();\n                    }\n\n                    if (s3 !== peg$FAILED) {\n                      peg$reportedPos = s0;\n                      s1 = peg$c18(s2, s3);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              }\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parsepluralFormatPattern() {\n          var s0, s1, s2, s3;\n          s0 = peg$currPos;\n          s1 = peg$parseoffsetPattern();\n\n          if (s1 === peg$FAILED) {\n            s1 = peg$c5;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsepluralForm();\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parsepluralForm();\n              }\n            } else {\n              s2 = peg$c2;\n            }\n\n            if (s2 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c19(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parseoffsetPattern() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 6) === peg$c20) {\n              s2 = peg$c20;\n              peg$currPos += 6;\n            } else {\n              s2 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c21);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 58) {\n                  s4 = peg$c22;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c23);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsedigits();\n\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n\n                      if (s7 !== peg$FAILED) {\n                        peg$reportedPos = s0;\n                        s1 = peg$c24(s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parsepluralForm() {\n          var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsepluralKey();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 123) {\n                  s4 = peg$c3;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c4);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsemessageFormatPattern();\n\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n\n                      if (s7 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 125) {\n                          s8 = peg$c8;\n                          peg$currPos++;\n                        } else {\n                          s8 = peg$FAILED;\n\n                          if (peg$silentFails === 0) {\n                            peg$fail(peg$c9);\n                          }\n                        }\n\n                        if (s8 !== peg$FAILED) {\n                          peg$reportedPos = s0;\n                          s1 = peg$c25(s2, s6);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parsepluralKey() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = peg$parseid();\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c26(s1);\n          }\n\n          s0 = s1;\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s1 = peg$c27;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c28);\n              }\n            }\n\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsedigits();\n\n              if (s2 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c24(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parseselectFormatPattern() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parseselectForm();\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parseselectForm();\n            }\n          } else {\n            s1 = peg$c2;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c29(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parseselectForm() {\n          var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseid();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 123) {\n                  s4 = peg$c3;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c4);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parsemessageFormatPattern();\n\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$parse_();\n\n                      if (s7 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 125) {\n                          s8 = peg$c8;\n                          peg$currPos++;\n                        } else {\n                          s8 = peg$FAILED;\n\n                          if (peg$silentFails === 0) {\n                            peg$fail(peg$c9);\n                          }\n                        }\n\n                        if (s8 !== peg$FAILED) {\n                          peg$reportedPos = s0;\n                          s1 = peg$c25(s2, s6);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parseargStylePattern() {\n          var s0, s1, s2, s3, s4, s5;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s2 = peg$c6;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c7);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseid();\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n\n                  if (s5 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c30(s4);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c2;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c2;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          return s0;\n        }\n\n        function peg$parseoctothorpe() {\n          var s0, s1;\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 35) {\n            s1 = peg$c31;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c32);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c33();\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsestring() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsechars();\n\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsewhitespace();\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsechars();\n\n              if (s2 === peg$FAILED) {\n                s2 = peg$parsewhitespace();\n              }\n            }\n          } else {\n            s1 = peg$c2;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c34(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parseid() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          peg$silentFails++;\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = peg$currPos;\n\n            if (peg$c36.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c37);\n              }\n            }\n\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n\n              if (peg$c38.test(input.charAt(peg$currPos))) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c39);\n                }\n              }\n\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n\n                if (peg$c38.test(input.charAt(peg$currPos))) {\n                  s6 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c39);\n                  }\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c2;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c2;\n            }\n\n            if (s3 !== peg$FAILED) {\n              s3 = input.substring(s2, peg$currPos);\n            }\n\n            s2 = s3;\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c40(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c2;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c2;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c2;\n          }\n\n          peg$silentFails--;\n\n          if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c35);\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parsechars() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsechar();\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$parsechar();\n            }\n          } else {\n            s1 = peg$c2;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c41(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsechar() {\n          var s0, s1, s2, s3, s4, s5;\n          s0 = peg$currPos;\n\n          if (peg$c42.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c43);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c44(s1);\n          }\n\n          s0 = s1;\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n\n            if (input.substr(peg$currPos, 2) === peg$c45) {\n              s1 = peg$c45;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c46);\n              }\n            }\n\n            if (s1 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c47();\n            }\n\n            s0 = s1;\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n\n              if (input.substr(peg$currPos, 2) === peg$c48) {\n                s1 = peg$c48;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c49);\n                }\n              }\n\n              if (s1 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c50();\n              }\n\n              s0 = s1;\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n\n                if (input.substr(peg$currPos, 2) === peg$c51) {\n                  s1 = peg$c51;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n\n                  if (peg$silentFails === 0) {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s1 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c53();\n                }\n\n                s0 = s1;\n\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n\n                  if (input.substr(peg$currPos, 2) === peg$c54) {\n                    s1 = peg$c54;\n                    peg$currPos += 2;\n                  } else {\n                    s1 = peg$FAILED;\n\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$c55);\n                    }\n                  }\n\n                  if (s1 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c56();\n                  }\n\n                  s0 = s1;\n\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n\n                    if (input.substr(peg$currPos, 2) === peg$c57) {\n                      s1 = peg$c57;\n                      peg$currPos += 2;\n                    } else {\n                      s1 = peg$FAILED;\n\n                      if (peg$silentFails === 0) {\n                        peg$fail(peg$c58);\n                      }\n                    }\n\n                    if (s1 !== peg$FAILED) {\n                      s2 = peg$parsehexDigit();\n\n                      if (s2 !== peg$FAILED) {\n                        s3 = peg$parsehexDigit();\n\n                        if (s3 !== peg$FAILED) {\n                          s4 = peg$parsehexDigit();\n\n                          if (s4 !== peg$FAILED) {\n                            s5 = peg$parsehexDigit();\n\n                            if (s5 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c59(s2, s3, s4, s5);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c2;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c2;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c2;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c2;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c2;\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parsedigits() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c61);\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c61);\n                }\n              }\n            }\n          } else {\n            s1 = peg$c2;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c62(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsehexDigit() {\n          var s0;\n\n          if (peg$c63.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c64);\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parse_() {\n          var s0, s1, s2;\n          peg$silentFails++;\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$parsewhitespace();\n\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parsewhitespace();\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c66(s1);\n          }\n\n          s0 = s1;\n          peg$silentFails--;\n\n          if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c65);\n            }\n          }\n\n          return s0;\n        }\n\n        function peg$parsewhitespace() {\n          var s0;\n\n          if (peg$c67.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c68);\n            }\n          }\n\n          return s0;\n        }\n\n        peg$result = peg$startRuleFunction();\n\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail({\n              type: \"end\",\n              description: \"end of input\"\n            });\n          }\n\n          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n        }\n      }\n\n      return {\n        SyntaxError: SyntaxError,\n        parse: parse\n      };\n    }().parse;\n    /** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript\n     *  @author Alex Sexton - @SlexAxton\n     *  @version 0.3.0-1\n     *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors\n     *  @license To use or fork, MIT. To contribute back, Dojo CLA  */\n\n    /** Utility function for quoting an Object's key value iff required\n     *  @private  */\n\n\n    function propname(key, obj) {\n      if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {\n        return obj ? obj + '.' + key : key;\n      } else {\n        var jkey = JSON.stringify(key);\n        return obj ? obj + '[' + jkey + ']' : jkey;\n      }\n    }\n\n    ;\n    /** Create a new message formatter\n     *\n     *  @class\n     *  @global\n     *  @param {string|string[]} [locale=\"en\"] - The locale to use, with fallbacks\n     *  @param {function} [pluralFunc] - Optional custom pluralization function\n     *  @param {function[]} [formatters] - Optional custom formatting functions  */\n\n    function MessageFormat(locale, pluralFunc, formatters) {\n      this.lc = [locale];\n      this.runtime.pluralFuncs = {};\n      this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;\n      this.runtime.fmt = {};\n      if (formatters) for (var f in formatters) {\n        this.runtime.fmt[f] = formatters[f];\n      }\n    }\n    /** Parse an input string to its AST\n     *\n     *  Precompiled from `lib/messageformat-parser.pegjs` by\n     *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object\n     *  to enable testing.\n     *\n     *  @private  */\n\n    /** Pluralization functions from\n     *  {@link http://github.com/eemeli/make-plural.js make-plural}\n     *\n     *  @memberof MessageFormat\n     *  @type Object.<string,function>  */\n\n\n    MessageFormat.plurals = {};\n    /** Default number formatting functions in the style of ICU's\n     *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}\n     *  implemented using the\n     *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}\n     *  object defined by ECMA-402.\n     *\n     *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so\n     *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.\n     *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these\n     *  functions to be available for inclusion in the output.\n     *\n     *  @see MessageFormat#setIntlSupport\n     *\n     *  @namespace\n     *  @memberof MessageFormat\n     *  @property {function} number - Represent a number as an integer, percent or currency value\n     *  @property {function} date - Represent a date as a full/long/default/short string\n     *  @property {function} time - Represent a time as a full/long/default/short string\n     *\n     *  @example\n     *  > var MessageFormat = require('messageformat');\n     *  > var mf = (new MessageFormat('en')).setIntlSupport(true);\n     *  > mf.currency = 'EUR';\n     *  > var mfunc = mf.compile(\"The total is {V,number,currency}.\");\n     *  > mfunc({V:5.5})\n     *  \"The total is 5.50.\"\n     *\n     *  @example\n     *  > var MessageFormat = require('messageformat');\n     *  > var mf = new MessageFormat('en', null, {number: MessageFormat.number});\n     *  > mf.currency = 'EUR';\n     *  > var mfunc = mf.compile(\"The total is {V,number,currency}.\");\n     *  > mfunc({V:5.5})\n     *  \"The total is 5.50.\"  */\n\n    MessageFormat.formatters = {};\n    /** Enable or disable support for the default formatters, which require the\n     *  `Intl` object. Note that this can't be autodetected, as the environment\n     *  in which the formatted text is compiled into Javascript functions is not\n     *  necessarily the same environment in which they will get executed.\n     *\n     *  @see MessageFormat.formatters\n     *\n     *  @memberof MessageFormat\n     *  @param {boolean} [enable=true]\n     *  @returns {Object} The MessageFormat instance, to allow for chaining\n     *  @example\n     *  > var Intl = require('intl');\n     *  > var MessageFormat = require('messageformat');\n     *  > var mf = (new MessageFormat('en')).setIntlSupport(true);\n     *  > mf.currency = 'EUR';\n     *  > mf.compile(\"The total is {V,number,currency}.\")({V:5.5});\n     *  \"The total is 5.50.\"  */\n\n    /** A set of utility functions that are called by the compiled Javascript\n     *  functions, these are included locally in the output of {@link\n     *  MessageFormat#compile compile()}.\n     *\n     *  @namespace\n     *  @memberof MessageFormat  */\n\n    MessageFormat.prototype.runtime = {\n      /** Utility function for `#` in plural rules\n       *\n       *  @param {number} value - The value to operate on\n       *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */\n      number: function (value, offset) {\n        if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n        return value - (offset || 0);\n      },\n\n      /** Utility function for `{N, plural|selectordinal, ...}`\n       *\n       *  @param {number} value - The key to use to find a pluralization rule\n       *  @param {number} offset - An offset to apply to `value`\n       *  @param {function} lcfunc - A locale function from `pluralFuncs`\n       *  @param {Object.<string,string>} data - The object from which results are looked up\n       *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules\n       *  @returns {string} The result of the pluralization  */\n      plural: function (value, offset, lcfunc, data, isOrdinal) {\n        if ({}.hasOwnProperty.call(data, value)) return data[value]();\n        if (offset) value -= offset;\n        var key = lcfunc(value, isOrdinal);\n        if (key in data) return data[key]();\n        return data.other();\n      },\n\n      /** Utility function for `{N, select, ...}`\n       *\n       *  @param {number} value - The key to use to find a selection\n       *  @param {Object.<string,string>} data - The object from which results are looked up\n       *  @returns {string} The result of the select statement  */\n      select: function (value, data) {\n        if ({}.hasOwnProperty.call(data, value)) return data[value]();\n        return data.other();\n      },\n\n      /** Pluralization functions included in compiled output\n       *  @instance\n       *  @type Object.<string,function>  */\n      pluralFuncs: {},\n\n      /** Custom formatting functions called by `{var, fn[, args]*}` syntax\n       *\n       *  For examples, see {@link MessageFormat.formatters}\n       *\n       *  @instance\n       *  @see MessageFormat.formatters\n       *  @type Object.<string,function>  */\n      fmt: {},\n\n      /** Custom stringifier to clean up browser inconsistencies\n       *  @instance  */\n      toString: function () {\n        var _stringify = function (o, level) {\n          if (typeof o != 'object') {\n            var funcStr = o.toString().replace(/^(function )\\w*/, '$1');\n            var indent = /([ \\t]*)\\S.*$/.exec(funcStr);\n            return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;\n          }\n\n          var s = [];\n\n          for (var i in o) if (i != 'toString') {\n            if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\\n');else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));\n          }\n\n          if (level == 0) return s.join('');\n          if (s.length == 0) return '{}';\n          var indent = '  ';\n\n          while (--level) indent += '  ';\n\n          return '{\\n' + s.join(',\\n').replace(/^/gm, indent) + '\\n}';\n        };\n\n        return _stringify(this, 0);\n      }\n    };\n    /** Recursively map an AST to its resulting string\n     *\n     *  @memberof MessageFormat\n     *\n     *  @param ast - the Ast node for which the JS code should be generated\n     *\n     *  @private  */\n\n    MessageFormat.prototype._precompile = function (ast, data) {\n      data = data || {\n        keys: {},\n        offset: {}\n      };\n      var r = [],\n          i,\n          tmp,\n          args = [];\n\n      switch (ast.type) {\n        case 'messageFormatPattern':\n          for (i = 0; i < ast.statements.length; ++i) {\n            r.push(this._precompile(ast.statements[i], data));\n          }\n\n          tmp = r.join(' + ') || '\"\"';\n          return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';\n\n        case 'messageFormatElement':\n          data.pf_count = data.pf_count || 0;\n\n          if (ast.output) {\n            return propname(ast.argumentIndex, 'd');\n          } else {\n            data.keys[data.pf_count] = ast.argumentIndex;\n            return this._precompile(ast.elementFormat, data);\n          }\n\n          return '';\n\n        case 'elementFormat':\n          args = [propname(data.keys[data.pf_count], 'd')];\n\n          switch (ast.key) {\n            case 'select':\n              args.push(this._precompile(ast.val, data));\n              return 'select(' + args.join(', ') + ')';\n\n            case 'selectordinal':\n              args = args.concat([0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1]);\n              return 'plural(' + args.join(', ') + ')';\n\n            case 'plural':\n              data.offset[data.pf_count || 0] = ast.val.offset || 0;\n              args = args.concat([data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data)]);\n              return 'plural(' + args.join(', ') + ')';\n\n            default:\n              if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && ast.key in MessageFormat.formatters) {\n                tmp = MessageFormat.formatters[ast.key];\n                this.runtime.fmt[ast.key] = typeof tmp(this) == 'function' ? tmp(this) : tmp;\n              }\n\n              args.push(JSON.stringify(this.lc));\n              if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));\n              return 'fmt.' + ast.key + '(' + args.join(', ') + ')';\n          }\n\n        case 'pluralFormatPattern':\n        case 'selectFormatPattern':\n          data.pf_count = data.pf_count || 0;\n          if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;\n          var needOther = true;\n\n          for (i = 0; i < ast.pluralForms.length; ++i) {\n            var key = ast.pluralForms[i].key;\n            if (key === 'other') needOther = false;\n            var data_copy = JSON.parse(JSON.stringify(data));\n            data_copy.pf_count++;\n            r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');\n          }\n\n          if (needOther) throw new Error(\"No 'other' form found in \" + ast.type + \" \" + data.pf_count);\n          return '{ ' + r.join(', ') + ' }';\n\n        case 'string':\n          return JSON.stringify(ast.val || \"\");\n\n        case 'octothorpe':\n          if (!data.pf_count) return '\"#\"';\n          args = [propname(data.keys[data.pf_count - 1], 'd')];\n          if (data.offset[data.pf_count - 1]) args.push(data.offset[data.pf_count - 1]);\n          return 'number(' + args.join(', ') + ')';\n\n        default:\n          throw new Error('Bad AST type: ' + ast.type);\n      }\n    };\n    /** Compile messages into an executable function with clean string\n     *  representation.\n     *\n     *  If `messages` is a single string including ICU MessageFormat declarations,\n     *  `opt` is ignored and the returned function takes a single Object parameter\n     *  `d` representing each of the input's defined variables. The returned\n     *  function will be defined in a local scope that includes all the required\n     *  runtime variables.\n     *\n     *  If `messages` is a map of keys to strings, or a map of namespace keys to\n     *  such key/string maps, the returned function will fill the specified global\n     *  with javascript functions matching the structure of the input. In such use,\n     *  the output of `compile()` is expected to be serialized using `.toString()`,\n     *  and will include definitions of the runtime functions. If `opt.global` is\n     *  null, calling the output function will return the object itself.\n     *\n     *  Together, the input parameters should match the following patterns:\n     *  ```js\n     *  messages = \"string\" || { key0: \"string0\", key1: \"string1\", ... } || {\n     *    ns0: { key0: \"string0\", key1: \"string1\", ...  },\n     *    ns1: { key0: \"string0\", key1: \"string1\", ...  },\n     *    ...\n     *  }\n     *\n     *  opt = null || {\n     *    locale: null || {\n     *      ns0: \"lc0\" || [ \"lc0\", ... ],\n     *      ns1: \"lc1\" || [ \"lc1\", ... ],\n     *      ...\n     *    },\n     *    global: null || \"module.exports\" || \"exports\" || \"i18n\" || ...\n     *  }\n     *  ```\n     *\n     *  @memberof MessageFormat\n     *  @param {string|Object}\n     *      messages - The input message(s) to be compiled, in ICU MessageFormat\n     *  @param {Object} [opt={}] - Options controlling output for non-simple intput\n     *  @param {Object} [opt.locale] - The locales to use for the messages, with a\n     *      structure matching that of `messages`\n     *  @param {string} [opt.global=\"\"] - The global variable that the output\n     *      function should use, or a null string for none. \"exports\" and\n     *      \"module.exports\" are recognised as special cases.\n     *  @returns {function} The first match found for the given locale(s)\n     *\n     *  @example\n     * > var MessageFormat = require('messageformat'),\n     * ...   mf = new MessageFormat('en'),\n     * ...   mfunc0 = mf.compile('A {TYPE} example.');\n     * > mfunc0({TYPE:'simple'})\n     * 'A simple example.'\n     * > mfunc0.toString()\n     * 'function (d) { return \"A \" + d.TYPE + \" example.\"; }'\n     *\n     *  @example\n     * > var msgSet = { a: 'A {TYPE} example.',\n     * ...              b: 'This has {COUNT, plural, one{one member} other{# members}}.' },\n     * ...   mfuncSet = mf.compile(msgSet);\n     * > mfuncSet().a({TYPE:'more complex'})\n     * 'A more complex example.'\n     * > mfuncSet().b({COUNT:2})\n     * 'This has 2 members.'\n     *\n     * > console.log(mfuncSet.toString())\n     * function anonymous() {\n     * var number = function (value, offset) {\n     *   if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n     *   return value - (offset || 0);\n     * };\n     * var plural = function (value, offset, lcfunc, data, isOrdinal) {\n     *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n     *   if (offset) value -= offset;\n     *   var key = lcfunc(value, isOrdinal);\n     *   if (key in data) return data[key]();\n     *   return data.other();\n     * };\n     * var select = function (value, data) {\n     *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n     *   return data.other()\n     * };\n     * var pluralFuncs = {\n     *   en: function (n, ord) {\n     *     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n     *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n     *     if (ord) return (n10 == 1 && n100 != 11) ? 'one'\n     *         : (n10 == 2 && n100 != 12) ? 'two'\n     *         : (n10 == 3 && n100 != 13) ? 'few'\n     *         : 'other';\n     *     return (n == 1 && v0) ? 'one' : 'other';\n     *   }\n     * };\n     * var fmt = {};\n     *\n     * return {\n     *   a: function(d) { return \"A \" + d.TYPE + \" example.\"; },\n     *   b: function(d) { return \"This has \" + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return \"one member\";}, other: function() { return number(d.COUNT)+\" members\";} }) + \".\"; }\n     * }\n     * }\n     *\n     *  @example\n     * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;\n     * > var multiSet = { en: { a: 'A {TYPE} example.',\n     * ...                      b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },\n     * ...                fi: { a: '{TYPE} esimerkki.',\n     * ...                      b: 'Tm on {COUNT, selectordinal, other{#.}} esimerkki.' } },\n     * ...   multiSetLocales = { en: 'en', fi: 'fi' },\n     * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: 'i18n' });\n     * > mfuncSet(this);\n     * > i18n.en.b({COUNT:3})\n     * 'This is the 3rd example.'\n     * > i18n.fi.b({COUNT:3})\n     * 'Tm on 3. esimerkki.'  */\n\n\n    MessageFormat.prototype.compile = function (messages, opt) {\n      var r = {},\n          lc0 = this.lc,\n          compileMsg = function (self, msg) {\n        try {\n          var ast = MessageFormat._parse(msg);\n\n          return self._precompile(ast);\n        } catch (e) {\n          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());\n        }\n      },\n          stringify = function (r, level) {\n        if (!level) level = 0;\n        if (typeof r != 'object') return r;\n        var o = [],\n            indent = '';\n\n        for (var i = 0; i < level; ++i) indent += '  ';\n\n        for (var k in r) o.push('\\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));\n\n        return '{' + o.join(',') + '\\n' + indent + '}';\n      };\n\n      if (typeof messages == 'string') {\n        var f = new Function('number, plural, select, pluralFuncs, fmt', 'return ' + compileMsg(this, messages));\n        return f(this.runtime.number, this.runtime.plural, this.runtime.select, this.runtime.pluralFuncs, this.runtime.fmt);\n      }\n\n      opt = opt || {};\n\n      for (var ns in messages) {\n        if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;\n\n        if (typeof messages[ns] == 'string') {\n          try {\n            r[ns] = compileMsg(this, messages[ns]);\n          } catch (e) {\n            e.message = e.message.replace(':', ' with `' + ns + '`:');\n            throw e;\n          }\n        } else {\n          r[ns] = {};\n\n          for (var key in messages[ns]) {\n            try {\n              r[ns][key] = compileMsg(this, messages[ns][key]);\n            } catch (e) {\n              e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:');\n              throw e;\n            }\n          }\n        }\n      }\n\n      this.lc = lc0;\n      var s = this.runtime.toString() + '\\n';\n\n      switch (opt.global || '') {\n        case 'exports':\n          var o = [];\n\n          for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));\n\n          return new Function(s + o.join(';\\n'));\n\n        case 'module.exports':\n          return new Function(s + 'module.exports = ' + stringify(r));\n\n        case '':\n          return new Function(s + 'return ' + stringify(r));\n\n        default:\n          return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));\n      }\n    };\n\n    return MessageFormat;\n  }();\n  /* jshint ignore:end */\n\n\n  var createErrorPluralModulePresence = function () {\n    return createError(\"E_MISSING_PLURAL_MODULE\", \"Plural module not loaded.\");\n  };\n\n  var validateMessageBundle = function (cldr) {\n    validate(\"E_MISSING_MESSAGE_BUNDLE\", \"Missing message bundle for locale `{locale}`.\", cldr.attributes.bundle && cldr.get(\"globalize-messages/{bundle}\") !== undefined, {\n      locale: cldr.locale\n    });\n  };\n\n  var validateMessagePresence = function (path, value) {\n    path = path.join(\"/\");\n    validate(\"E_MISSING_MESSAGE\", \"Missing required message content `{path}`.\", value !== undefined, {\n      path: path\n    });\n  };\n\n  var validateMessageType = function (path, value) {\n    path = path.join(\"/\");\n    validate(\"E_INVALID_MESSAGE\", \"Invalid message content `{path}`. {expected} expected.\", typeof value === \"string\", {\n      expected: \"a string\",\n      path: path\n    });\n  };\n\n  var validateParameterTypeMessageVariables = function (value, name) {\n    validateParameterType(value, name, value === undefined || isPlainObject(value) || Array.isArray(value), \"Array or Plain Object\");\n  };\n\n  var messageFormatterFn = function (formatter) {\n    return function messageFormatter(variables) {\n      if (typeof variables === \"number\" || typeof variables === \"string\") {\n        variables = [].slice.call(arguments, 0);\n      }\n\n      validateParameterTypeMessageVariables(variables, \"variables\");\n      return formatter(variables);\n    };\n  };\n\n  var messageFormatterRuntimeBind = function (cldr, messageformatter) {\n    var locale = cldr.locale,\n        origToString = messageformatter.toString;\n\n    messageformatter.toString = function () {\n      var argNames,\n          argValues,\n          output,\n          args = {}; // Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:\n\n      output = origToString.call(messageformatter);\n\n      if (/number\\(/.test(output)) {\n        args.number = \"messageFormat.number\";\n      }\n\n      if (/plural\\(/.test(output)) {\n        args.plural = \"messageFormat.plural\";\n      }\n\n      if (/select\\(/.test(output)) {\n        args.select = \"messageFormat.select\";\n      }\n\n      output.replace(/pluralFuncs(\\[([^\\]]+)\\]|\\.([a-zA-Z]+))/, function (match) {\n        args.pluralFuncs = \"{\" + \"\\\"\" + locale + \"\\\": Globalize(\\\"\" + locale + \"\\\").pluralGenerator()\" + \"}\";\n        return match;\n      });\n      argNames = Object.keys(args).join(\", \");\n      argValues = Object.keys(args).map(function (key) {\n        return args[key];\n      }).join(\", \");\n      return \"(function( \" + argNames + \" ) {\\n\" + \"  return \" + output + \"\\n\" + \"})(\" + argValues + \")\";\n    };\n\n    return messageformatter;\n  };\n\n  var slice = [].slice;\n  /**\n   * .loadMessages( json )\n   *\n   * @json [JSON]\n   *\n   * Load translation data.\n   */\n\n  Globalize.loadMessages = function (json) {\n    var locale,\n        customData = {\n      \"globalize-messages\": json,\n      \"main\": {}\n    };\n    validateParameterPresence(json, \"json\");\n    validateParameterTypePlainObject(json, \"json\"); // Set available bundles by populating customData main dataset.\n\n    for (locale in json) {\n      if (json.hasOwnProperty(locale)) {\n        customData.main[locale] = {};\n      }\n    }\n\n    Cldr.load(customData);\n  };\n  /**\n   * .messageFormatter( path )\n   *\n   * @path [String or Array]\n   *\n   * Format a message given its path.\n   */\n\n\n  Globalize.messageFormatter = Globalize.prototype.messageFormatter = function (path) {\n    var cldr,\n        formatter,\n        message,\n        pluralGenerator,\n        returnFn,\n        args = slice.call(arguments, 0);\n    validateParameterPresence(path, \"path\");\n    validateParameterType(path, \"path\", typeof path === \"string\" || Array.isArray(path), \"a String nor an Array\");\n    path = alwaysArray(path);\n    cldr = this.cldr;\n    validateDefaultLocale(cldr);\n    validateMessageBundle(cldr);\n    message = cldr.get([\"globalize-messages/{bundle}\"].concat(path));\n    validateMessagePresence(path, message); // If message is an Array, concatenate it.\n\n    if (Array.isArray(message)) {\n      message = message.join(\" \");\n    }\n\n    validateMessageType(path, message); // Is plural module present? Yes, use its generator. Nope, use an error generator.\n\n    pluralGenerator = this.plural !== undefined ? this.pluralGenerator() : createErrorPluralModulePresence;\n    formatter = new MessageFormat(cldr.locale, pluralGenerator).compile(message);\n    returnFn = messageFormatterFn(formatter);\n    runtimeBind(args, cldr, returnFn, [messageFormatterRuntimeBind(cldr, formatter), pluralGenerator]);\n    return returnFn;\n  };\n  /**\n   * .formatMessage( path [, variables] )\n   *\n   * @path [String or Array]\n   *\n   * @variables [Number, String, Array or Object]\n   *\n   * Format a message given its path.\n   */\n\n\n  Globalize.formatMessage = Globalize.prototype.formatMessage = function (path\n  /* , variables */\n  ) {\n    return this.messageFormatter(path).apply({}, slice.call(arguments, 1));\n  };\n\n  return Globalize;\n});","map":null,"metadata":{},"sourceType":"script"}