{"ast":null,"code":"/**\n * Globalize v1.4.2\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2019-03-07T13:47Z\n */\n\n/*!\n * Globalize v1.4.2 2019-03-07T13:47Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  // UMD returnExports\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"cldr\", \"../globalize\", \"./number\", \"cldr/event\", \"cldr/supplemental\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"cldrjs\"), require(\"../globalize\"));\n  } else {\n    // Extend global\n    factory(root.Cldr, root.Globalize);\n  }\n})(this, function (Cldr, Globalize) {\n  var createError = Globalize._createError,\n      createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,\n      formatMessage = Globalize._formatMessage,\n      isPlainObject = Globalize._isPlainObject,\n      looseMatching = Globalize._looseMatching,\n      numberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap,\n      numberSymbol = Globalize._numberSymbol,\n      regexpEscape = Globalize._regexpEscape,\n      removeLiteralQuotes = Globalize._removeLiteralQuotes,\n      runtimeBind = Globalize._runtimeBind,\n      stringPad = Globalize._stringPad,\n      validate = Globalize._validate,\n      validateCldr = Globalize._validateCldr,\n      validateDefaultLocale = Globalize._validateDefaultLocale,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,\n      validateParameterTypeString = Globalize._validateParameterTypeString;\n\n  var validateParameterTypeDate = function (value, name) {\n    validateParameterType(value, name, value === undefined || value instanceof Date, \"Date\");\n  };\n\n  var createErrorInvalidParameterValue = function (name, value) {\n    return createError(\"E_INVALID_PAR_VALUE\", \"Invalid `{name}` value ({value}).\", {\n      name: name,\n      value: value\n    });\n  };\n  /**\n   * Create a map between the skeleton fields and their positions, e.g.,\n   * {\n   *   G: 0\n   *   y: 1\n   *   ...\n   * }\n   */\n\n\n  var validateSkeletonFieldsPosMap = \"GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx\".split(\"\").reduce(function (memo, item, i) {\n    memo[item] = i;\n    return memo;\n  }, {});\n  /**\n   * validateSkeleton( skeleton )\n   *\n   * skeleton: Assume `j` has already been converted into a localized hour field.\n   */\n\n  var validateSkeleton = function validateSkeleton(skeleton) {\n    var last,\n        // Using easier to read variable.\n    fieldsPosMap = validateSkeletonFieldsPosMap; // \"The fields are from the Date Field Symbol Table in Date Format Patterns\"\n    // Ref: http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n    // I.e., check for invalid characters.\n\n    skeleton.replace(/[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function (field) {\n      throw createError(\"E_INVALID_OPTIONS\", \"Invalid field `{invalidField}` of skeleton `{value}`\", {\n        invalidField: field,\n        type: \"skeleton\",\n        value: skeleton\n      });\n    }); // \"The canonical order is from top to bottom in that table; that is, yM not My\".\n    // http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n    // I.e., check for invalid order.\n\n    skeleton.split(\"\").every(function (field) {\n      if (fieldsPosMap[field] < last) {\n        throw createError(\"E_INVALID_OPTIONS\", \"Invalid order `{invalidField}` of skeleton `{value}`\", {\n          invalidField: field,\n          type: \"skeleton\",\n          value: skeleton\n        });\n      }\n\n      last = fieldsPosMap[field];\n      return true;\n    });\n  };\n  /**\n   * Returns a new object created by using `object`'s values as keys, and the keys as values.\n   */\n\n\n  var objectInvert = function (object, fn) {\n    fn = fn || function (object, key, value) {\n      object[value] = key;\n      return object;\n    };\n\n    return Object.keys(object).reduce(function (newObject, key) {\n      return fn(newObject, key, object[key]);\n    }, {});\n  }; // Invert key and values, e.g., {\"e\": \"eEc\"} ==> {\"e\": \"e\", \"E\": \"e\", \"c\": \"e\"}.\n\n\n  var dateExpandPatternSimilarFieldsMap = objectInvert({\n    \"e\": \"eEc\",\n    \"L\": \"ML\"\n  }, function (object, key, value) {\n    value.split(\"\").forEach(function (field) {\n      object[field] = key;\n    });\n    return object;\n  });\n\n  var dateExpandPatternNormalizePatternType = function (character) {\n    return dateExpandPatternSimilarFieldsMap[character] || character;\n  };\n\n  var datePatternRe = /([a-z])\\1*|'([^']|'')+'|''|./ig;\n\n  var stringRepeat = function (str, count) {\n    var i,\n        result = \"\";\n\n    for (i = 0; i < count; i++) {\n      result = result + str;\n    }\n\n    return result;\n  };\n\n  function expandBestMatchFormat(skeletonWithoutFractionalSeconds, bestMatchFormat) {\n    var i,\n        j,\n        bestMatchFormatParts,\n        matchedType,\n        matchedLength,\n        requestedType,\n        requestedLength,\n        requestedSkeletonParts,\n        // Using an easier to read variable.\n    normalizePatternType = dateExpandPatternNormalizePatternType;\n    requestedSkeletonParts = skeletonWithoutFractionalSeconds.match(datePatternRe);\n    bestMatchFormatParts = bestMatchFormat.match(datePatternRe);\n\n    for (i = 0; i < bestMatchFormatParts.length; i++) {\n      matchedType = bestMatchFormatParts[i].charAt(0);\n      matchedLength = bestMatchFormatParts[i].length;\n\n      for (j = 0; j < requestedSkeletonParts.length; j++) {\n        requestedType = requestedSkeletonParts[j].charAt(0);\n        requestedLength = requestedSkeletonParts[j].length;\n\n        if (normalizePatternType(matchedType) === normalizePatternType(requestedType) && matchedLength < requestedLength) {\n          bestMatchFormatParts[i] = stringRepeat(matchedType, requestedLength);\n        }\n      }\n    }\n\n    return bestMatchFormatParts.join(\"\");\n  } // See: http://www.unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n\n\n  var dateExpandPatternAugmentFormat = function (requestedSkeleton, bestMatchFormat, decimalSeparator) {\n    var countOfFractionalSeconds, fractionalSecondMatch, lastSecondIdx, skeletonWithoutFractionalSeconds;\n    fractionalSecondMatch = requestedSkeleton.match(/S/g);\n    countOfFractionalSeconds = fractionalSecondMatch ? fractionalSecondMatch.length : 0;\n    skeletonWithoutFractionalSeconds = requestedSkeleton.replace(/S/g, \"\");\n    bestMatchFormat = expandBestMatchFormat(skeletonWithoutFractionalSeconds, bestMatchFormat);\n    lastSecondIdx = bestMatchFormat.lastIndexOf(\"s\");\n\n    if (lastSecondIdx !== -1 && countOfFractionalSeconds !== 0) {\n      bestMatchFormat = bestMatchFormat.slice(0, lastSecondIdx + 1) + decimalSeparator + stringRepeat(\"S\", countOfFractionalSeconds) + bestMatchFormat.slice(lastSecondIdx + 1);\n    }\n\n    return bestMatchFormat;\n  };\n\n  var dateExpandPatternCompareFormats = function (formatA, formatB) {\n    var a,\n        b,\n        distance,\n        lenA,\n        lenB,\n        typeA,\n        typeB,\n        i,\n        j,\n        // Using easier to read variables.\n    normalizePatternType = dateExpandPatternNormalizePatternType;\n\n    if (formatA === formatB) {\n      return 0;\n    }\n\n    formatA = formatA.match(datePatternRe);\n    formatB = formatB.match(datePatternRe);\n\n    if (formatA.length !== formatB.length) {\n      return -1;\n    }\n\n    distance = 1;\n\n    for (i = 0; i < formatA.length; i++) {\n      a = formatA[i].charAt(0);\n      typeA = normalizePatternType(a);\n      typeB = null;\n\n      for (j = 0; j < formatB.length; j++) {\n        b = formatB[j].charAt(0);\n        typeB = normalizePatternType(b);\n\n        if (typeA === typeB) {\n          break;\n        } else {\n          typeB = null;\n        }\n      }\n\n      if (typeB === null) {\n        return -1;\n      }\n\n      lenA = formatA[i].length;\n      lenB = formatB[j].length;\n      distance = distance + Math.abs(lenA - lenB); // Most symbols have a small distance from each other, e.g., M ≅ L; E ≅ c; a ≅ b ≅ B;\n      // H ≅ k ≅ h ≅ K; ...\n\n      if (a !== b) {\n        distance += 1;\n      } // Numeric (l<3) and text fields (l>=3) are given a larger distance from each other.\n\n\n      if (lenA < 3 && lenB >= 3 || lenA >= 3 && lenB < 3) {\n        distance += 20;\n      }\n    }\n\n    return distance;\n  };\n\n  var dateExpandPatternGetBestMatchPattern = function (cldr, askedSkeleton) {\n    var availableFormats,\n        decimalSeparator,\n        pattern,\n        ratedFormats,\n        skeleton,\n        path = \"dates/calendars/gregorian/dateTimeFormats/availableFormats\",\n        // Using easier to read variables.\n    augmentFormat = dateExpandPatternAugmentFormat,\n        compareFormats = dateExpandPatternCompareFormats;\n    pattern = cldr.main([path, askedSkeleton]);\n\n    if (askedSkeleton && !pattern) {\n      availableFormats = cldr.main([path]);\n      ratedFormats = [];\n\n      for (skeleton in availableFormats) {\n        ratedFormats.push({\n          skeleton: skeleton,\n          pattern: availableFormats[skeleton],\n          rate: compareFormats(askedSkeleton, skeleton)\n        });\n      }\n\n      ratedFormats = ratedFormats.filter(function (format) {\n        return format.rate > -1;\n      }).sort(function (formatA, formatB) {\n        return formatA.rate - formatB.rate;\n      });\n\n      if (ratedFormats.length) {\n        decimalSeparator = numberSymbol(\"decimal\", cldr);\n        pattern = augmentFormat(askedSkeleton, ratedFormats[0].pattern, decimalSeparator);\n      }\n    }\n\n    return pattern;\n  };\n  /**\n   * expandPattern( options, cldr )\n   *\n   * @options [Object] if String, it's considered a skeleton. Object accepts:\n   * - skeleton: [String] lookup availableFormat;\n   * - date: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n   * - time: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n   * - datetime: [String] ( \"full\" | \"long\" | \"medium\" | \"short\" );\n   * - raw: [String] For more info see datetime/format.js.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the corresponding pattern.\n   * Eg for \"en\":\n   * - \"GyMMMd\" returns \"MMM d, y G\";\n   * - { skeleton: \"GyMMMd\" } returns \"MMM d, y G\";\n   * - { date: \"full\" } returns \"EEEE, MMMM d, y\";\n   * - { time: \"full\" } returns \"h:mm:ss a zzzz\";\n   * - { datetime: \"full\" } returns \"EEEE, MMMM d, y 'at' h:mm:ss a zzzz\";\n   * - { raw: \"dd/mm\" } returns \"dd/mm\";\n   */\n\n\n  var dateExpandPattern = function (options, cldr) {\n    var dateSkeleton,\n        result,\n        skeleton,\n        timeSkeleton,\n        type,\n        // Using easier to read variables.\n    getBestMatchPattern = dateExpandPatternGetBestMatchPattern;\n\n    function combineDateTime(type, datePattern, timePattern) {\n      return formatMessage(cldr.main([\"dates/calendars/gregorian/dateTimeFormats\", type]), [timePattern, datePattern]);\n    }\n\n    switch (true) {\n      case \"skeleton\" in options:\n        skeleton = options.skeleton; // Preferred hour (j).\n\n        skeleton = skeleton.replace(/j/g, function () {\n          return cldr.supplemental.timeData.preferred();\n        });\n        validateSkeleton(skeleton); // Try direct map (note that getBestMatchPattern handles it).\n        // ... or, try to \"best match\" the whole skeleton.\n\n        result = getBestMatchPattern(cldr, skeleton);\n\n        if (result) {\n          break;\n        } // ... or, try to \"best match\" the date and time parts individually.\n\n\n        timeSkeleton = skeleton.split(/[^hHKkmsSAzZOvVXx]/).slice(-1)[0];\n        dateSkeleton = skeleton.split(/[^GyYuUrQqMLlwWdDFgEec]/)[0];\n        dateSkeleton = getBestMatchPattern(cldr, dateSkeleton);\n        timeSkeleton = getBestMatchPattern(cldr, timeSkeleton);\n\n        if (/(MMMM|LLLL).*[Ec]/.test(dateSkeleton)) {\n          type = \"full\";\n        } else if (/MMMM|LLLL/.test(dateSkeleton)) {\n          type = \"long\";\n        } else if (/MMM|LLL/.test(dateSkeleton)) {\n          type = \"medium\";\n        } else {\n          type = \"short\";\n        }\n\n        if (dateSkeleton && timeSkeleton) {\n          result = combineDateTime(type, dateSkeleton, timeSkeleton);\n        } else {\n          result = dateSkeleton || timeSkeleton;\n        }\n\n        break;\n\n      case \"date\" in options:\n      case \"time\" in options:\n        result = cldr.main([\"dates/calendars/gregorian\", \"date\" in options ? \"dateFormats\" : \"timeFormats\", options.date || options.time]);\n        break;\n\n      case \"datetime\" in options:\n        result = combineDateTime(options.datetime, cldr.main([\"dates/calendars/gregorian/dateFormats\", options.datetime]), cldr.main([\"dates/calendars/gregorian/timeFormats\", options.datetime]));\n        break;\n\n      case \"raw\" in options:\n        result = options.raw;\n        break;\n\n      default:\n        throw createErrorInvalidParameterValue({\n          name: \"options\",\n          value: options\n        });\n    }\n\n    return result;\n  };\n\n  var dateWeekDays = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"];\n  /**\n   * firstDayOfWeek\n   */\n\n  var dateFirstDayOfWeek = function (cldr) {\n    return dateWeekDays.indexOf(cldr.supplemental.weekData.firstDay());\n  };\n  /**\n   * getTimeZoneName( length, type )\n   */\n\n\n  var dateGetTimeZoneName = function (length, type, timeZone, cldr) {\n    var metaZone, result;\n\n    if (!timeZone) {\n      return;\n    }\n\n    result = cldr.main([\"dates/timeZoneNames/zone\", timeZone, length < 4 ? \"short\" : \"long\", type]);\n\n    if (result) {\n      return result;\n    } // The latest metazone data of the metazone array.\n    // TODO expand to support the historic metazones based on the given date.\n\n\n    metaZone = cldr.supplemental([\"metaZones/metazoneInfo/timezone\", timeZone, 0, \"usesMetazone/_mzone\"]);\n    return cldr.main([\"dates/timeZoneNames/metazone\", metaZone, length < 4 ? \"short\" : \"long\", type]);\n  };\n  /**\n   * timezoneHourFormatShortH( hourFormat )\n   *\n   * @hourFormat [String]\n   *\n   * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.\n   * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n   *\n   * Example:\n   * - \"+HH.mm;-HH.mm\" => \"+H;-H\"\n   * - \"+HH:mm;-HH:mm\" => \"+H;-H\"\n   * - \"+HH:mm;−HH:mm\" => \"+H;−H\" (Note MINUS SIGN \\u2212)\n   * - \"+HHmm;-HHmm\" => \"+H:-H\"\n   */\n\n\n  var dateTimezoneHourFormatH = function (hourFormat) {\n    return hourFormat.split(\";\").map(function (format) {\n      return format.slice(0, format.indexOf(\"H\") + 1);\n    }).join(\";\");\n  };\n  /**\n   * timezoneHourFormatLongHm( hourFormat )\n   *\n   * @hourFormat [String]\n   *\n   * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.\n   * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n   *\n   * Example (hFormat === \"H\"): (used for short Hm)\n   * - \"+HH.mm;-HH.mm\" => \"+H.mm;-H.mm\"\n   * - \"+HH:mm;-HH:mm\" => \"+H:mm;-H:mm\"\n   * - \"+HH:mm;−HH:mm\" => \"+H:mm;−H:mm\" (Note MINUS SIGN \\u2212)\n   * - \"+HHmm;-HHmm\" => \"+Hmm:-Hmm\"\n   *\n   * Example (hFormat === \"HH\": (used for long Hm)\n   * - \"+HH.mm;-HH.mm\" => \"+HH.mm;-HH.mm\"\n   * - \"+HH:mm;-HH:mm\" => \"+HH:mm;-HH:mm\"\n   * - \"+H:mm;-H:mm\"   => \"+HH:mm;-HH:mm\"\n   * - \"+HH:mm;−HH:mm\" => \"+HH:mm;−HH:mm\" (Note MINUS SIGN \\u2212)\n   * - \"+HHmm;-HHmm\" => \"+HHmm:-HHmm\"\n   */\n\n\n  var dateTimezoneHourFormatHm = function (hourFormat, hFormat) {\n    return hourFormat.split(\";\").map(function (format) {\n      var parts = format.split(/H+/);\n      parts.splice(1, 0, hFormat);\n      return parts.join(\"\");\n    }).join(\";\");\n  };\n\n  var runtimeCacheDataBind = function (key, data) {\n    var fn = function () {\n      return data;\n    };\n\n    fn.dataCacheKey = key;\n    return fn;\n  };\n  /**\n   * properties( pattern, cldr )\n   *\n   * @pattern [String] raw pattern.\n   * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the properties given the pattern and cldr.\n   *\n   * TODO Support other calendar types.\n   */\n\n\n  var dateFormatProperties = function (pattern, cldr, timeZone) {\n    var properties = {\n      numberFormatters: {},\n      pattern: pattern,\n      timeSeparator: numberSymbol(\"timeSeparator\", cldr)\n    },\n        widths = [\"abbreviated\", \"wide\", \"narrow\"];\n\n    function setNumberFormatterPattern(pad) {\n      properties.numberFormatters[pad] = stringPad(\"\", pad);\n    }\n\n    if (timeZone) {\n      properties.timeZoneData = runtimeCacheDataBind(\"iana/\" + timeZone, {\n        offsets: cldr.get([\"globalize-iana/zoneData\", timeZone, \"offsets\"]),\n        untils: cldr.get([\"globalize-iana/zoneData\", timeZone, \"untils\"]),\n        isdsts: cldr.get([\"globalize-iana/zoneData\", timeZone, \"isdsts\"])\n      });\n    }\n\n    pattern.replace(datePatternRe, function (current) {\n      var aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;\n      chr = current.charAt(0);\n      length = current.length;\n\n      if (chr === \"j\") {\n        // Locale preferred hHKk.\n        // http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n        properties.preferredTime = chr = cldr.supplemental.timeData.preferred();\n      } // ZZZZ: same as \"OOOO\".\n\n\n      if (chr === \"Z\" && length === 4) {\n        chr = \"O\";\n        length = 4;\n      } // z...zzz: \"{shortRegion}\", eg. \"PST\" or \"PDT\".\n      // zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n      //       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"z\") {\n        standardTzName = dateGetTimeZoneName(length, \"standard\", timeZone, cldr);\n        daylightTzName = dateGetTimeZoneName(length, \"daylight\", timeZone, cldr);\n\n        if (standardTzName) {\n          properties.standardTzName = standardTzName;\n        }\n\n        if (daylightTzName) {\n          properties.daylightTzName = daylightTzName;\n        } // Fall through the \"O\" format in case one name is missing.\n\n\n        if (!standardTzName || !daylightTzName) {\n          chr = \"O\";\n\n          if (length < 4) {\n            length = 1;\n          }\n        }\n      } // v...vvv: \"{shortRegion}\", eg. \"PT\".\n      // vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n      // e.g., \"Pacific Time\"\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"v\") {\n        genericTzName = dateGetTimeZoneName(length, \"generic\", timeZone, cldr); // Fall back to \"V\" format.\n\n        if (!genericTzName) {\n          chr = \"V\";\n          length = 4;\n        }\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          properties.eras = cldr.main([\"dates/calendars/gregorian/eras\", length <= 3 ? \"eraAbbr\" : length === 4 ? \"eraNames\" : \"eraNarrow\"]);\n          break;\n        // Year\n\n        case \"y\":\n          // Plain year.\n          formatNumber = true;\n          break;\n\n        case \"Y\":\n          // Year in \"Week of Year\"\n          properties.firstDay = dateFirstDayOfWeek(cldr);\n          properties.minDays = cldr.supplemental.weekData.minDays();\n          formatNumber = true;\n          break;\n\n        case \"u\": // Extended year. Need to be implemented.\n\n        case \"U\":\n          // Cyclic year name. Need to be implemented.\n          throw createErrorUnsupportedFeature({\n            feature: \"year pattern `\" + chr + \"`\"\n          });\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          if (length > 2) {\n            if (!properties.quarters) {\n              properties.quarters = {};\n            }\n\n            if (!properties.quarters[chr]) {\n              properties.quarters[chr] = {};\n            }\n\n            properties.quarters[chr][length] = cldr.main([\"dates/calendars/gregorian/quarters\", chr === \"Q\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          } else {\n            formatNumber = true;\n          }\n\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          if (length > 2) {\n            if (!properties.months) {\n              properties.months = {};\n            }\n\n            if (!properties.months[chr]) {\n              properties.months[chr] = {};\n            }\n\n            properties.months[chr][length] = cldr.main([\"dates/calendars/gregorian/months\", chr === \"M\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          } else {\n            formatNumber = true;\n          }\n\n          break;\n        // Week - Week of Year (w) or Week of Month (W).\n\n        case \"w\":\n        case \"W\":\n          properties.firstDay = dateFirstDayOfWeek(cldr);\n          properties.minDays = cldr.supplemental.weekData.minDays();\n          formatNumber = true;\n          break;\n        // Day\n\n        case \"d\":\n        case \"D\":\n        case \"F\":\n          formatNumber = true;\n          break;\n\n        case \"g\":\n          // Modified Julian day. Need to be implemented.\n          throw createErrorUnsupportedFeature({\n            feature: \"Julian day pattern `g`\"\n          });\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          if (length <= 2) {\n            properties.firstDay = dateFirstDayOfWeek(cldr);\n            formatNumber = true;\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          if (!properties.days) {\n            properties.days = {};\n          }\n\n          if (!properties.days[chr]) {\n            properties.days[chr] = {};\n          }\n\n          if (length === 6) {\n            // If short day names are not explicitly specified, abbreviated day names are\n            // used instead.\n            // http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n            // http://unicode.org/cldr/trac/ticket/6790\n            properties.days[chr][length] = cldr.main([\"dates/calendars/gregorian/days\", chr === \"c\" ? \"stand-alone\" : \"format\", \"short\"]) || cldr.main([\"dates/calendars/gregorian/days\", chr === \"c\" ? \"stand-alone\" : \"format\", \"abbreviated\"]);\n          } else {\n            properties.days[chr][length] = cldr.main([\"dates/calendars/gregorian/days\", chr === \"c\" ? \"stand-alone\" : \"format\", widths[length < 3 ? 0 : length - 3]]);\n          }\n\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          properties.dayPeriods = {\n            am: cldr.main(\"dates/calendars/gregorian/dayPeriods/format/wide/am\"),\n            pm: cldr.main(\"dates/calendars/gregorian/dayPeriods/format/wide/pm\")\n          };\n          break;\n        // Hour\n\n        case \"h\": // 1-12\n\n        case \"H\": // 0-23\n\n        case \"K\": // 0-11\n\n        case \"k\": // 1-24\n        // Minute\n\n        case \"m\": // Second\n\n        case \"s\":\n        case \"S\":\n        case \"A\":\n          formatNumber = true;\n          break;\n        // Zone\n\n        case \"v\":\n          if (length !== 1 && length !== 4) {\n            throw createErrorUnsupportedFeature({\n              feature: \"timezone pattern `\" + pattern + \"`\"\n            });\n          }\n\n          properties.genericTzName = genericTzName;\n          break;\n\n        case \"V\":\n          if (length === 1) {\n            throw createErrorUnsupportedFeature({\n              feature: \"timezone pattern `\" + pattern + \"`\"\n            });\n          }\n\n          if (timeZone) {\n            if (length === 2) {\n              properties.timeZoneName = timeZone;\n              break;\n            }\n\n            var timeZoneName,\n                exemplarCity = cldr.main([\"dates/timeZoneNames/zone\", timeZone, \"exemplarCity\"]);\n\n            if (length === 3) {\n              if (!exemplarCity) {\n                exemplarCity = cldr.main([\"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity\"]);\n              }\n\n              timeZoneName = exemplarCity;\n            }\n\n            if (exemplarCity && length === 4) {\n              timeZoneName = formatMessage(cldr.main(\"dates/timeZoneNames/regionFormat\"), [exemplarCity]);\n            }\n\n            if (timeZoneName) {\n              properties.timeZoneName = timeZoneName;\n              break;\n            }\n          }\n\n          if (current === \"v\") {\n            length = 1;\n          }\n\n        /* falls through */\n\n        case \"O\":\n          // O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n          // OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n          properties.gmtFormat = cldr.main(\"dates/timeZoneNames/gmtFormat\");\n          properties.gmtZeroFormat = cldr.main(\"dates/timeZoneNames/gmtZeroFormat\"); // Unofficial deduction of the hourFormat variations.\n          // Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\n\n          aux = cldr.main(\"dates/timeZoneNames/hourFormat\");\n          properties.hourFormat = length < 4 ? [dateTimezoneHourFormatH(aux), dateTimezoneHourFormatHm(aux, \"H\")] : dateTimezoneHourFormatHm(aux, \"HH\");\n\n        /* falls through */\n\n        case \"Z\":\n        case \"X\":\n        case \"x\":\n          setNumberFormatterPattern(1);\n          setNumberFormatterPattern(2);\n          break;\n      }\n\n      if (formatNumber) {\n        setNumberFormatterPattern(length);\n      }\n    });\n    return properties;\n  };\n\n  var dateFormatterFn = function (dateToPartsFormatter) {\n    return function dateFormatter(value) {\n      return dateToPartsFormatter(value).map(function (part) {\n        return part.value;\n      }).join(\"\");\n    };\n  };\n  /**\n   * parseProperties( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * @timeZone [String] FIXME.\n   *\n   * Return parser properties.\n   */\n\n\n  var dateParseProperties = function (cldr, timeZone) {\n    var properties = {\n      preferredTimeData: cldr.supplemental.timeData.preferred()\n    };\n\n    if (timeZone) {\n      properties.timeZoneData = runtimeCacheDataBind(\"iana/\" + timeZone, {\n        offsets: cldr.get([\"globalize-iana/zoneData\", timeZone, \"offsets\"]),\n        untils: cldr.get([\"globalize-iana/zoneData\", timeZone, \"untils\"]),\n        isdsts: cldr.get([\"globalize-iana/zoneData\", timeZone, \"isdsts\"])\n      });\n    }\n\n    return properties;\n  };\n\n  var ZonedDateTime = function () {\n    function definePrivateProperty(object, property, value) {\n      Object.defineProperty(object, property, {\n        value: value\n      });\n    }\n\n    function getUntilsIndex(original, untils) {\n      var index = 0;\n      var originalTime = original.getTime(); // TODO Should we do binary search for improved performance?\n\n      while (index < untils.length - 1 && originalTime >= untils[index]) {\n        index++;\n      }\n\n      return index;\n    }\n\n    function setWrap(fn) {\n      var offset1 = this.getTimezoneOffset();\n      var ret = fn();\n      this.original.setTime(new Date(this.getTime()));\n      var offset2 = this.getTimezoneOffset();\n\n      if (offset2 - offset1) {\n        this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);\n      }\n\n      return ret;\n    }\n\n    var ZonedDateTime = function (date, timeZoneData) {\n      definePrivateProperty(this, \"original\", new Date(date.getTime()));\n      definePrivateProperty(this, \"local\", new Date(date.getTime()));\n      definePrivateProperty(this, \"timeZoneData\", timeZoneData);\n      definePrivateProperty(this, \"setWrap\", setWrap);\n\n      if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {\n        throw new Error(\"Invalid IANA data\");\n      }\n\n      this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);\n    };\n\n    ZonedDateTime.prototype.clone = function () {\n      return new ZonedDateTime(this.original, this.timeZoneData);\n    }; // Date field getters.\n\n\n    [\"getFullYear\", \"getMonth\", \"getDate\", \"getDay\", \"getHours\", \"getMinutes\", \"getSeconds\", \"getMilliseconds\"].forEach(function (method) {\n      // Corresponding UTC method, e.g., \"getUTCFullYear\" if method === \"getFullYear\".\n      var utcMethod = \"getUTC\" + method.substr(3);\n\n      ZonedDateTime.prototype[method] = function () {\n        return this.local[utcMethod]();\n      };\n    }); // Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.\n\n    ZonedDateTime.prototype.valueOf = ZonedDateTime.prototype.getTime = function () {\n      return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;\n    };\n\n    ZonedDateTime.prototype.getTimezoneOffset = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      return this.timeZoneData.offsets[index];\n    }; // Date field setters.\n\n\n    [\"setFullYear\", \"setMonth\", \"setDate\", \"setHours\", \"setMinutes\", \"setSeconds\", \"setMilliseconds\"].forEach(function (method) {\n      // Corresponding UTC method, e.g., \"setUTCFullYear\" if method === \"setFullYear\".\n      var utcMethod = \"setUTC\" + method.substr(3);\n\n      ZonedDateTime.prototype[method] = function (value) {\n        var local = this.local; // Note setWrap is needed for seconds and milliseconds just because\n        // abs(value) could be >= a minute.\n\n        return this.setWrap(function () {\n          return local[utcMethod](value);\n        });\n      };\n    });\n\n    ZonedDateTime.prototype.setTime = function (time) {\n      return this.local.setTime(time);\n    };\n\n    ZonedDateTime.prototype.isDST = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      return Boolean(this.timeZoneData.isdsts[index]);\n    };\n\n    ZonedDateTime.prototype.inspect = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      var abbrs = this.timeZoneData.abbrs;\n      return this.local.toISOString().replace(/Z$/, \"\") + \" \" + (abbrs && abbrs[index] + \" \" || this.getTimezoneOffset() * -1 + \" \") + (this.isDST() ? \"(daylight savings)\" : \"\");\n    };\n\n    ZonedDateTime.prototype.toDate = function () {\n      return new Date(this.getTime());\n    }; // Type cast getters.\n\n\n    [\"toISOString\", \"toJSON\", \"toUTCString\"].forEach(function (method) {\n      ZonedDateTime.prototype[method] = function () {\n        return this.toDate()[method]();\n      };\n    });\n    return ZonedDateTime;\n  }();\n  /**\n   * isLeapYear( year )\n   *\n   * @year [Number]\n   *\n   * Returns an indication whether the specified year is a leap year.\n   */\n\n\n  var dateIsLeapYear = function (year) {\n    return new Date(year, 1, 29).getMonth() === 1;\n  };\n  /**\n   * lastDayOfMonth( date )\n   *\n   * @date [Date]\n   *\n   * Return the last day of the given date's month\n   */\n\n\n  var dateLastDayOfMonth = function (date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n  };\n  /**\n   * startOf changes the input to the beginning of the given unit.\n   *\n   * For example, starting at the start of a day, resets hours, minutes\n   * seconds and milliseconds to 0. Starting at the month does the same, but\n   * also sets the date to 1.\n   *\n   * Returns the modified date\n   */\n\n\n  var dateStartOf = function (date, unit) {\n    date = date instanceof ZonedDateTime ? date.clone() : new Date(date.getTime());\n\n    switch (unit) {\n      case \"year\":\n        date.setMonth(0);\n\n      /* falls through */\n\n      case \"month\":\n        date.setDate(1);\n\n      /* falls through */\n\n      case \"day\":\n        date.setHours(0);\n\n      /* falls through */\n\n      case \"hour\":\n        date.setMinutes(0);\n\n      /* falls through */\n\n      case \"minute\":\n        date.setSeconds(0);\n\n      /* falls through */\n\n      case \"second\":\n        date.setMilliseconds(0);\n    }\n\n    return date;\n  };\n  /**\n   * Differently from native date.setDate(), this function returns a date whose\n   * day remains inside the month boundaries. For example:\n   *\n   * setDate( FebDate, 31 ): a \"Feb 28\" date.\n   * setDate( SepDate, 31 ): a \"Sep 30\" date.\n   */\n\n\n  var dateSetDate = function (date, day) {\n    var lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n    date.setDate(day < 1 ? 1 : day < lastDay ? day : lastDay);\n  };\n  /**\n   * Differently from native date.setMonth(), this function adjusts date if\n   * needed, so final month is always the one set.\n   *\n   * setMonth( Jan31Date, 1 ): a \"Feb 28\" date.\n   * setDate( Jan31Date, 8 ): a \"Sep 30\" date.\n   */\n\n\n  var dateSetMonth = function (date, month) {\n    var originalDate = date.getDate();\n    date.setDate(1);\n    date.setMonth(month);\n    dateSetDate(date, originalDate);\n  };\n\n  var outOfRange = function (value, low, high) {\n    return value < low || value > high;\n  };\n  /**\n   * parse( value, tokens, properties )\n   *\n   * @value [String] string date.\n   *\n   * @tokens [Object] tokens returned by date/tokenizer.\n   *\n   * @properties [Object] output returned by date/tokenizer-properties.\n   *\n   * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n   */\n\n\n  var dateParse = function (value, tokens, properties) {\n    var amPm,\n        day,\n        daysOfYear,\n        month,\n        era,\n        hour,\n        hour12,\n        timezoneOffset,\n        valid,\n        YEAR = 0,\n        MONTH = 1,\n        DAY = 2,\n        HOUR = 3,\n        MINUTE = 4,\n        SECOND = 5,\n        MILLISECONDS = 6,\n        date = new Date(),\n        truncateAt = [],\n        units = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"milliseconds\"]; // Create globalize date with given timezone data.\n\n    if (properties.timeZoneData) {\n      date = new ZonedDateTime(date, properties.timeZoneData());\n    }\n\n    if (!tokens.length) {\n      return null;\n    }\n\n    valid = tokens.every(function (token) {\n      var century, chr, value, length;\n\n      if (token.type === \"literal\") {\n        // continue\n        return true;\n      }\n\n      chr = token.type.charAt(0);\n      length = token.type.length;\n\n      if (chr === \"j\") {\n        // Locale preferred hHKk.\n        // http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n        chr = properties.preferredTimeData;\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          truncateAt.push(YEAR);\n          era = +token.value;\n          break;\n        // Year\n\n        case \"y\":\n          value = token.value;\n\n          if (length === 2) {\n            if (outOfRange(value, 0, 99)) {\n              return false;\n            } // mimic dojo/date/locale: choose century to apply, according to a sliding\n            // window of 80 years before and 20 years after present year.\n\n\n            century = Math.floor(date.getFullYear() / 100) * 100;\n            value += century;\n\n            if (value > date.getFullYear() + 20) {\n              value -= 100;\n            }\n          }\n\n          date.setFullYear(value);\n          truncateAt.push(YEAR);\n          break;\n\n        case \"Y\":\n          // Year in \"Week of Year\"\n          throw createErrorUnsupportedFeature({\n            feature: \"year pattern `\" + chr + \"`\"\n          });\n        // Quarter (skip)\n\n        case \"Q\":\n        case \"q\":\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          if (length <= 2) {\n            value = token.value;\n          } else {\n            value = +token.value;\n          }\n\n          if (outOfRange(value, 1, 12)) {\n            return false;\n          } // Setting the month later so that we have the correct year and can determine\n          // the correct last day of February in case of leap year.\n\n\n          month = value;\n          truncateAt.push(MONTH);\n          break;\n        // Week (skip)\n\n        case \"w\": // Week of Year.\n\n        case \"W\":\n          // Week of Month.\n          break;\n        // Day\n\n        case \"d\":\n          day = token.value;\n          truncateAt.push(DAY);\n          break;\n\n        case \"D\":\n          daysOfYear = token.value;\n          truncateAt.push(DAY);\n          break;\n\n        case \"F\":\n          // Day of Week in month. eg. 2nd Wed in July.\n          // Skip\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n        case \"E\":\n          // Skip.\n          // value = arrayIndexOf( dateWeekDays, token.value );\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          amPm = token.value;\n          break;\n        // Hour\n\n        case \"h\":\n          // 1-12\n          value = token.value;\n\n          if (outOfRange(value, 1, 12)) {\n            return false;\n          }\n\n          hour = hour12 = true;\n          date.setHours(value === 12 ? 0 : value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"K\":\n          // 0-11\n          value = token.value;\n\n          if (outOfRange(value, 0, 11)) {\n            return false;\n          }\n\n          hour = hour12 = true;\n          date.setHours(value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"k\":\n          // 1-24\n          value = token.value;\n\n          if (outOfRange(value, 1, 24)) {\n            return false;\n          }\n\n          hour = true;\n          date.setHours(value === 24 ? 0 : value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"H\":\n          // 0-23\n          value = token.value;\n\n          if (outOfRange(value, 0, 23)) {\n            return false;\n          }\n\n          hour = true;\n          date.setHours(value);\n          truncateAt.push(HOUR);\n          break;\n        // Minute\n\n        case \"m\":\n          value = token.value;\n\n          if (outOfRange(value, 0, 59)) {\n            return false;\n          }\n\n          date.setMinutes(value);\n          truncateAt.push(MINUTE);\n          break;\n        // Second\n\n        case \"s\":\n          value = token.value;\n\n          if (outOfRange(value, 0, 59)) {\n            return false;\n          }\n\n          date.setSeconds(value);\n          truncateAt.push(SECOND);\n          break;\n\n        case \"A\":\n          date.setHours(0);\n          date.setMinutes(0);\n          date.setSeconds(0);\n\n        /* falls through */\n\n        case \"S\":\n          value = Math.round(token.value * Math.pow(10, 3 - length));\n          date.setMilliseconds(value);\n          truncateAt.push(MILLISECONDS);\n          break;\n        // Zone\n\n        case \"z\":\n        case \"Z\":\n        case \"O\":\n        case \"v\":\n        case \"V\":\n        case \"X\":\n        case \"x\":\n          if (typeof token.value === \"number\") {\n            timezoneOffset = token.value;\n          }\n\n          break;\n      }\n\n      return true;\n    });\n\n    if (!valid) {\n      return null;\n    } // 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null\n    // if amPm && !hour12 || !amPm && hour12.\n\n\n    if (hour && !(!amPm ^ hour12)) {\n      return null;\n    }\n\n    if (era === 0) {\n      // 1 BC = year 0\n      date.setFullYear(date.getFullYear() * -1 + 1);\n    }\n\n    if (month !== undefined) {\n      dateSetMonth(date, month - 1);\n    }\n\n    if (day !== undefined) {\n      if (outOfRange(day, 1, dateLastDayOfMonth(date))) {\n        return null;\n      }\n\n      date.setDate(day);\n    } else if (daysOfYear !== undefined) {\n      if (outOfRange(daysOfYear, 1, dateIsLeapYear(date.getFullYear()) ? 366 : 365)) {\n        return null;\n      }\n\n      date.setMonth(0);\n      date.setDate(daysOfYear);\n    }\n\n    if (hour12 && amPm === \"pm\") {\n      date.setHours(date.getHours() + 12);\n    }\n\n    if (timezoneOffset !== undefined) {\n      date.setMinutes(date.getMinutes() + timezoneOffset - date.getTimezoneOffset());\n    } // Truncate date at the most precise unit defined. Eg.\n    // If value is \"12/31\", and pattern is \"MM/dd\":\n    // => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );\n\n\n    truncateAt = Math.max.apply(null, truncateAt);\n    date = dateStartOf(date, units[truncateAt]); // Get date back from globalize date.\n\n    if (date instanceof ZonedDateTime) {\n      date = date.toDate();\n    }\n\n    return date;\n  };\n  /**\n   * tokenizer( value, numberParser, properties )\n   *\n   * @value [String] string date.\n   *\n   * @numberParser [Function]\n   *\n   * @properties [Object] output returned by date/tokenizer-properties.\n   *\n   * Returns an Array of tokens, eg. value \"5 o'clock PM\", pattern \"h 'o''clock' a\":\n   * [{\n   *   type: \"h\",\n   *   lexeme: \"5\"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \" \"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \"o'clock\"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \" \"\n   * }, {\n   *   type: \"a\",\n   *   lexeme: \"PM\",\n   *   value: \"pm\"\n   * }]\n   *\n   * OBS: lexeme's are always String and may return invalid ranges depending of the token type.\n   * Eg. \"99\" for month number.\n   *\n   * Return an empty Array when not successfully parsed.\n   */\n\n\n  var dateTokenizer = function (value, numberParser, properties) {\n    var digitsRe,\n        valid,\n        tokens = [],\n        widths = [\"abbreviated\", \"wide\", \"narrow\"];\n    digitsRe = properties.digitsRe;\n    value = looseMatching(value);\n    valid = properties.pattern.match(datePatternRe).every(function (current) {\n      var aux,\n          chr,\n          length,\n          numeric,\n          tokenRe,\n          token = {};\n\n      function hourFormatParse(tokenRe, numberParser) {\n        var aux,\n            isPositive,\n            match = value.match(tokenRe);\n\n        numberParser = numberParser || function (value) {\n          return +value;\n        };\n\n        if (!match) {\n          return false;\n        }\n\n        isPositive = match[1]; // hourFormat containing H only, e.g., `+H;-H`\n\n        if (match.length < 6) {\n          aux = isPositive ? 1 : 3;\n          token.value = numberParser(match[aux]) * 60; // hourFormat containing H and m, e.g., `+HHmm;-HHmm`\n        } else if (match.length < 10) {\n          aux = isPositive ? [1, 3] : [5, 7];\n          token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]); // hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`\n        } else {\n          aux = isPositive ? [1, 3, 5] : [7, 9, 11];\n          token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]) + numberParser(match[aux[2]]) / 60;\n        }\n\n        if (isPositive) {\n          token.value *= -1;\n        }\n\n        return true;\n      }\n\n      function oneDigitIfLengthOne() {\n        if (length === 1) {\n          // Unicode equivalent to /\\d/\n          numeric = true;\n          return tokenRe = digitsRe;\n        }\n      }\n\n      function oneOrTwoDigitsIfLengthOne() {\n        if (length === 1) {\n          // Unicode equivalent to /\\d\\d?/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n        }\n      }\n\n      function oneOrTwoDigitsIfLengthOneOrTwo() {\n        if (length === 1 || length === 2) {\n          // Unicode equivalent to /\\d\\d?/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n        }\n      }\n\n      function twoDigitsIfLengthTwo() {\n        if (length === 2) {\n          // Unicode equivalent to /\\d\\d/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){2}\");\n        }\n      } // Brute-force test every locale entry in an attempt to match the given value.\n      // Return the first found one (and set token accordingly), or null.\n\n\n      function lookup(path) {\n        var array = properties[path.join(\"/\")];\n\n        if (!array) {\n          return null;\n        } // array of pairs [key, value] sorted by desc value length.\n\n\n        array.some(function (item) {\n          var valueRe = item[1];\n\n          if (valueRe.test(value)) {\n            token.value = item[0];\n            tokenRe = item[1];\n            return true;\n          }\n        });\n        return null;\n      }\n\n      token.type = current;\n      chr = current.charAt(0);\n      length = current.length;\n\n      if (chr === \"Z\") {\n        // Z..ZZZ: same as \"xxxx\".\n        if (length < 4) {\n          chr = \"x\";\n          length = 4; // ZZZZ: same as \"OOOO\".\n        } else if (length < 5) {\n          chr = \"O\";\n          length = 4; // ZZZZZ: same as \"XXXXX\"\n        } else {\n          chr = \"X\";\n          length = 5;\n        }\n      }\n\n      if (chr === \"z\") {\n        if (properties.standardOrDaylightTzName) {\n          token.value = null;\n          tokenRe = properties.standardOrDaylightTzName;\n        }\n      } // v...vvv: \"{shortRegion}\", eg. \"PT\".\n      // vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n      // e.g., \"Pacific Time\"\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"v\") {\n        if (properties.genericTzName) {\n          token.value = null;\n          tokenRe = properties.genericTzName; // Fall back to \"V\" format.\n        } else {\n          chr = \"V\";\n          length = 4;\n        }\n      }\n\n      if (chr === \"V\" && properties.timeZoneName) {\n        token.value = length === 2 ? properties.timeZoneName : null;\n        tokenRe = properties.timeZoneNameRe;\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          lookup([\"gregorian/eras\", length <= 3 ? \"eraAbbr\" : length === 4 ? \"eraNames\" : \"eraNarrow\"]);\n          break;\n        // Year\n\n        case \"y\":\n        case \"Y\":\n          numeric = true; // number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...\n\n          if (length === 1) {\n            // Unicode equivalent to /\\d+/.\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \")+\");\n          } else if (length === 2) {\n            // Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits\n            // year, so parser accepts both zero-padded and non-zero-padded for `yy`.\n            //\n            // Unicode equivalent to /\\d\\d?/\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n          } else {\n            // Unicode equivalent to /\\d{length,}/\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \",}\");\n          }\n\n          break;\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          // number l=1:{1}, l=2:{2}.\n          // lookup l=3...\n          oneDigitIfLengthOne() || twoDigitsIfLengthTwo() || lookup([\"gregorian/quarters\", chr === \"Q\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          // number l=1:{1,2}, l=2:{2}.\n          // lookup l=3...\n          //\n          // Lenient parsing: skeleton \"yMd\" (i.e., one M) may include MM for the pattern,\n          // therefore parser accepts both zero-padded and non-zero-padded for M and MM.\n          // Similar for L.\n          oneOrTwoDigitsIfLengthOneOrTwo() || lookup([\"gregorian/months\", chr === \"M\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          break;\n        // Day\n\n        case \"D\":\n          // number {l,3}.\n          if (length <= 3) {\n            // Equivalent to /\\d{length,3}/\n            numeric = true;\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \",3}\");\n          }\n\n          break;\n\n        case \"W\":\n        case \"F\":\n          // number l=1:{1}.\n          oneDigitIfLengthOne();\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          // number l=1:{1}, l=2:{2}.\n          // lookup for length >=3.\n          if (length <= 2) {\n            oneDigitIfLengthOne() || twoDigitsIfLengthTwo();\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          if (length === 6) {\n            // Note: if short day names are not explicitly specified, abbreviated day\n            // names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n            lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"short\"]) || lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"abbreviated\"]);\n          } else {\n            lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], widths[length < 3 ? 0 : length - 3]]);\n          }\n\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          lookup([\"gregorian/dayPeriods/format/wide\"]);\n          break;\n        // Week\n\n        case \"w\":\n          // number l1:{1,2}, l2:{2}.\n          oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();\n          break;\n        // Day, Hour, Minute, or Second\n\n        case \"d\":\n        case \"h\":\n        case \"H\":\n        case \"K\":\n        case \"k\":\n        case \"j\":\n        case \"m\":\n        case \"s\":\n          // number l1:{1,2}, l2:{2}.\n          //\n          // Lenient parsing:\n          // - skeleton \"hms\" (i.e., one m) always includes mm for the pattern, i.e., it's\n          //   impossible to use a different skeleton to parse non-zero-padded minutes,\n          //   therefore parser accepts both zero-padded and non-zero-padded for m. Similar\n          //   for seconds s.\n          // - skeleton \"hms\" (i.e., one h) may include h or hh for the pattern, i.e., it's\n          //   impossible to use a different skeleton to parser non-zero-padded hours for some\n          //   locales, therefore parser accepts both zero-padded and non-zero-padded for h.\n          //   Similar for d (in skeleton yMd).\n          oneOrTwoDigitsIfLengthOneOrTwo();\n          break;\n\n        case \"S\":\n          // number {l}.\n          // Unicode equivalent to /\\d{length}/\n          numeric = true;\n          tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \"}\");\n          break;\n\n        case \"A\":\n          // number {l+5}.\n          // Unicode equivalent to /\\d{length+5}/\n          numeric = true;\n          tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + (length + 5) + \"}\");\n          break;\n        // Zone\n\n        case \"v\":\n        case \"V\":\n        case \"z\":\n          if (tokenRe && tokenRe.test(value)) {\n            break;\n          }\n\n          if (chr === \"V\" && length === 2) {\n            break;\n          }\n\n        /* falls through */\n\n        case \"O\":\n          // O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n          // OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n          if (value === properties[\"timeZoneNames/gmtZeroFormat\"]) {\n            token.value = 0;\n            tokenRe = properties[\"timeZoneNames/gmtZeroFormatRe\"];\n          } else {\n            aux = properties[\"timeZoneNames/hourFormat\"].some(function (hourFormatRe) {\n              if (hourFormatParse(hourFormatRe, numberParser)) {\n                tokenRe = hourFormatRe;\n                return true;\n              }\n            });\n\n            if (!aux) {\n              return null;\n            }\n          }\n\n          break;\n\n        case \"X\":\n          // Same as x*, except it uses \"Z\" for zero offset.\n          if (value === \"Z\") {\n            token.value = 0;\n            tokenRe = /^Z/;\n            break;\n          }\n\n        /* falls through */\n\n        case \"x\":\n          // x: hourFormat(\"+HH[mm];-HH[mm]\")\n          // xx: hourFormat(\"+HHmm;-HHmm\")\n          // xxx: hourFormat(\"+HH:mm;-HH:mm\")\n          // xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n          // xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n          aux = properties.x.some(function (hourFormatRe) {\n            if (hourFormatParse(hourFormatRe)) {\n              tokenRe = hourFormatRe;\n              return true;\n            }\n          });\n\n          if (!aux) {\n            return null;\n          }\n\n          break;\n\n        case \"'\":\n          token.type = \"literal\";\n          tokenRe = new RegExp(\"^\" + regexpEscape(removeLiteralQuotes(current)));\n          break;\n\n        default:\n          token.type = \"literal\";\n          tokenRe = new RegExp(\"^\" + regexpEscape(current));\n      }\n\n      if (!tokenRe) {\n        return false;\n      } // Get lexeme and consume it.\n\n\n      value = value.replace(tokenRe, function (lexeme) {\n        token.lexeme = lexeme;\n\n        if (numeric) {\n          token.value = numberParser(lexeme);\n        }\n\n        return \"\";\n      });\n\n      if (!token.lexeme) {\n        return false;\n      }\n\n      if (numeric && isNaN(token.value)) {\n        return false;\n      }\n\n      tokens.push(token);\n      return true;\n    });\n\n    if (value !== \"\") {\n      valid = false;\n    }\n\n    return valid ? tokens : [];\n  };\n\n  var dateParserFn = function (numberParser, parseProperties, tokenizerProperties) {\n    return function dateParser(value) {\n      var tokens;\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeString(value, \"value\");\n      tokens = dateTokenizer(value, numberParser, tokenizerProperties);\n      return dateParse(value, tokens, parseProperties) || null;\n    };\n  };\n\n  var objectFilter = function (object, testRe) {\n    var key,\n        copy = {};\n\n    for (key in object) {\n      if (testRe.test(key)) {\n        copy[key] = object[key];\n      }\n    }\n\n    return copy;\n  };\n  /**\n   * tokenizerProperties( pattern, cldr )\n   *\n   * @pattern [String] raw pattern.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return Object with data that will be used by tokenizer.\n   */\n\n\n  var dateTokenizerProperties = function (pattern, cldr, timeZone) {\n    var digitsReSource,\n        properties = {\n      pattern: looseMatching(pattern)\n    },\n        timeSeparator = numberSymbol(\"timeSeparator\", cldr),\n        widths = [\"abbreviated\", \"wide\", \"narrow\"];\n    digitsReSource = numberNumberingSystemDigitsMap(cldr);\n    digitsReSource = digitsReSource ? \"[\" + digitsReSource + \"]\" : \"\\\\d\";\n    properties.digitsRe = new RegExp(digitsReSource); // Transform:\n    // - \"+H;-H\" -> /\\+(\\d\\d?)|-(\\d\\d?)/\n    // - \"+HH;-HH\" -> /\\+(\\d\\d)|-(\\d\\d)/\n    // - \"+HHmm;-HHmm\" -> /\\+(\\d\\d)(\\d\\d)|-(\\d\\d)(\\d\\d)/\n    // - \"+HH:mm;-HH:mm\" -> /\\+(\\d\\d):(\\d\\d)|-(\\d\\d):(\\d\\d)/\n    //\n    // If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:\n    // - \"+H;-H\" -> /GMT\\+(\\d\\d?)|GMT-(\\d\\d?)/\n\n    function hourFormatRe(hourFormat, gmtFormat, digitsReSource, timeSeparator) {\n      var re;\n\n      if (!digitsReSource) {\n        digitsReSource = \"\\\\d\";\n      }\n\n      if (!gmtFormat) {\n        gmtFormat = \"{0}\";\n      }\n\n      re = hourFormat.replace(\"+\", \"\\\\+\") // Unicode equivalent to (\\\\d\\\\d)\n      .replace(/HH|mm|ss/g, \"((\" + digitsReSource + \"){2})\") // Unicode equivalent to (\\\\d\\\\d?)\n      .replace(/H|m/g, \"((\" + digitsReSource + \"){1,2})\");\n\n      if (timeSeparator) {\n        re = re.replace(/:/g, timeSeparator);\n      }\n\n      re = re.split(\";\").map(function (part) {\n        return gmtFormat.replace(\"{0}\", part);\n      }).join(\"|\");\n      return new RegExp(\"^\" + re);\n    }\n\n    function populateProperties(path, value) {\n      // Skip\n      var skipRe = /(timeZoneNames\\/zone|supplemental\\/metaZones|timeZoneNames\\/metazone|timeZoneNames\\/regionFormat|timeZoneNames\\/gmtFormat)/;\n\n      if (skipRe.test(path)) {\n        return;\n      }\n\n      if (!value) {\n        return;\n      } // The `dates` and `calendars` trim's purpose is to reduce properties' key size only.\n\n\n      path = path.replace(/^.*\\/dates\\//, \"\").replace(/calendars\\//, \"\"); // Specific filter for \"gregorian/dayPeriods/format/wide\".\n\n      if (path === \"gregorian/dayPeriods/format/wide\") {\n        value = objectFilter(value, /^am|^pm/);\n      } // Transform object into array of pairs [key, /value/], sort by desc value length.\n\n\n      if (isPlainObject(value)) {\n        value = Object.keys(value).map(function (key) {\n          return [key, new RegExp(\"^\" + regexpEscape(looseMatching(value[key])))];\n        }).sort(function (a, b) {\n          return b[1].source.length - a[1].source.length;\n        }); // If typeof value === \"string\".\n      } else {\n        value = looseMatching(value);\n      }\n\n      properties[path] = value;\n    }\n\n    function regexpSourceSomeTerm(terms) {\n      return \"(\" + terms.filter(function (item) {\n        return item;\n      }).reduce(function (memo, item) {\n        return memo + \"|\" + item;\n      }) + \")\";\n    }\n\n    cldr.on(\"get\", populateProperties);\n    pattern.match(datePatternRe).forEach(function (current) {\n      var aux, chr, daylightTzName, gmtFormat, length, standardTzName;\n      chr = current.charAt(0);\n      length = current.length;\n\n      if (chr === \"Z\") {\n        if (length < 5) {\n          chr = \"O\";\n          length = 4;\n        } else {\n          chr = \"X\";\n          length = 5;\n        }\n      } // z...zzz: \"{shortRegion}\", eg. \"PST\" or \"PDT\".\n      // zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n      //       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"z\") {\n        standardTzName = dateGetTimeZoneName(length, \"standard\", timeZone, cldr);\n        daylightTzName = dateGetTimeZoneName(length, \"daylight\", timeZone, cldr);\n\n        if (standardTzName) {\n          standardTzName = regexpEscape(looseMatching(standardTzName));\n        }\n\n        if (daylightTzName) {\n          daylightTzName = regexpEscape(looseMatching(daylightTzName));\n        }\n\n        if (standardTzName || daylightTzName) {\n          properties.standardOrDaylightTzName = new RegExp(\"^\" + regexpSourceSomeTerm([standardTzName, daylightTzName]));\n        } // Fall through the \"O\" format in case one name is missing.\n\n\n        if (!standardTzName || !daylightTzName) {\n          chr = \"O\";\n\n          if (length < 4) {\n            length = 1;\n          }\n        }\n      } // v...vvv: \"{shortRegion}\", eg. \"PT\".\n      // vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n      // e.g., \"Pacific Time\"\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"v\") {\n        if (length !== 1 && length !== 4) {\n          throw createErrorUnsupportedFeature({\n            feature: \"timezone pattern `\" + pattern + \"`\"\n          });\n        }\n\n        var genericTzName = dateGetTimeZoneName(length, \"generic\", timeZone, cldr);\n\n        if (genericTzName) {\n          properties.genericTzName = new RegExp(\"^\" + regexpEscape(looseMatching(genericTzName)));\n          chr = \"O\"; // Fall back to \"V\" format.\n        } else {\n          chr = \"V\";\n          length = 4;\n        }\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          cldr.main([\"dates/calendars/gregorian/eras\", length <= 3 ? \"eraAbbr\" : length === 4 ? \"eraNames\" : \"eraNarrow\"]);\n          break;\n        // Year\n\n        case \"u\": // Extended year. Need to be implemented.\n\n        case \"U\":\n          // Cyclic year name. Need to be implemented.\n          throw createErrorUnsupportedFeature({\n            feature: \"year pattern `\" + chr + \"`\"\n          });\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          if (length > 2) {\n            cldr.main([\"dates/calendars/gregorian/quarters\", chr === \"Q\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          }\n\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          // number l=1:{1,2}, l=2:{2}.\n          // lookup l=3...\n          if (length > 2) {\n            cldr.main([\"dates/calendars/gregorian/months\", chr === \"M\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          }\n\n          break;\n        // Day\n\n        case \"g\":\n          // Modified Julian day. Need to be implemented.\n          throw createErrorUnsupportedFeature({\n            feature: \"Julian day pattern `g`\"\n          });\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          // lookup for length >=3.\n          if (length <= 2) {\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          if (length === 6) {\n            // Note: if short day names are not explicitly specified, abbreviated day\n            // names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n            cldr.main([\"dates/calendars/gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"short\"]) || cldr.main([\"dates/calendars/gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"abbreviated\"]);\n          } else {\n            cldr.main([\"dates/calendars/gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], widths[length < 3 ? 0 : length - 3]]);\n          }\n\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          cldr.main(\"dates/calendars/gregorian/dayPeriods/format/wide\");\n          break;\n        // Zone\n\n        case \"V\":\n          if (length === 1) {\n            throw createErrorUnsupportedFeature({\n              feature: \"timezone pattern `\" + pattern + \"`\"\n            });\n          }\n\n          if (timeZone) {\n            if (length === 2) {\n              // Skip looseMatching processing since timeZone is a canonical posix value.\n              properties.timeZoneName = timeZone;\n              properties.timeZoneNameRe = new RegExp(\"^\" + regexpEscape(timeZone));\n              break;\n            }\n\n            var timeZoneName,\n                exemplarCity = cldr.main([\"dates/timeZoneNames/zone\", timeZone, \"exemplarCity\"]);\n\n            if (length === 3) {\n              if (!exemplarCity) {\n                exemplarCity = cldr.main([\"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity\"]);\n              }\n\n              timeZoneName = exemplarCity;\n            }\n\n            if (exemplarCity && length === 4) {\n              timeZoneName = formatMessage(cldr.main(\"dates/timeZoneNames/regionFormat\"), [exemplarCity]);\n            }\n\n            if (timeZoneName) {\n              timeZoneName = looseMatching(timeZoneName);\n              properties.timeZoneName = timeZoneName;\n              properties.timeZoneNameRe = new RegExp(\"^\" + regexpEscape(timeZoneName));\n            }\n          }\n\n          if (current === \"v\") {\n            length = 1;\n          }\n\n        /* falls through */\n\n        case \"z\":\n        case \"O\":\n          gmtFormat = cldr.main(\"dates/timeZoneNames/gmtFormat\");\n          cldr.main(\"dates/timeZoneNames/gmtZeroFormat\");\n          cldr.main(\"dates/timeZoneNames/hourFormat\");\n          properties[\"timeZoneNames/gmtZeroFormatRe\"] = new RegExp(\"^\" + regexpEscape(properties[\"timeZoneNames/gmtZeroFormat\"]));\n          aux = properties[\"timeZoneNames/hourFormat\"];\n          properties[\"timeZoneNames/hourFormat\"] = (length < 4 ? [dateTimezoneHourFormatHm(aux, \"H\"), dateTimezoneHourFormatH(aux)] : [dateTimezoneHourFormatHm(aux, \"HH\")]).map(function (hourFormat) {\n            return hourFormatRe(hourFormat, gmtFormat, digitsReSource, timeSeparator);\n          });\n\n        /* falls through */\n\n        case \"X\":\n        case \"x\":\n          // x: hourFormat(\"+HH[mm];-HH[mm]\")\n          // xx: hourFormat(\"+HHmm;-HHmm\")\n          // xxx: hourFormat(\"+HH:mm;-HH:mm\")\n          // xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n          // xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n          properties.x = [[\"+HHmm;-HHmm\", \"+HH;-HH\"], [\"+HHmm;-HHmm\"], [\"+HH:mm;-HH:mm\"], [\"+HHmmss;-HHmmss\", \"+HHmm;-HHmm\"], [\"+HH:mm:ss;-HH:mm:ss\", \"+HH:mm;-HH:mm\"]][length - 1].map(function (hourFormat) {\n            return hourFormatRe(hourFormat);\n          });\n      }\n    });\n    cldr.off(\"get\", populateProperties);\n    return properties;\n  };\n  /**\n   * dayOfWeek( date, firstDay )\n   *\n   * @date\n   *\n   * @firstDay the result of `dateFirstDayOfWeek( cldr )`\n   *\n   * Return the day of the week normalized by the territory's firstDay [0-6].\n   * Eg for \"mon\":\n   * - return 0 if territory is GB, or BR, or DE, or FR (week starts on \"mon\");\n   * - return 1 if territory is US (week starts on \"sun\");\n   * - return 2 if territory is EG (week starts on \"sat\");\n   */\n\n\n  var dateDayOfWeek = function (date, firstDay) {\n    return (date.getDay() - firstDay + 7) % 7;\n  };\n  /**\n   * distanceInDays( from, to )\n   *\n   * Return the distance in days between from and to Dates.\n   */\n\n\n  var dateDistanceInDays = function (from, to) {\n    var inDays = 864e5;\n    return (to.getTime() - from.getTime()) / inDays;\n  };\n  /**\n   * dayOfYear\n   *\n   * Return the distance in days of the date to the begin of the year [0-d].\n   */\n\n\n  var dateDayOfYear = function (date) {\n    return Math.floor(dateDistanceInDays(dateStartOf(date, \"year\"), date));\n  }; // Invert key and values, e.g., {\"year\": \"yY\"} ==> {\"y\": \"year\", \"Y\": \"year\"}\n\n\n  var dateFieldsMap = objectInvert({\n    \"era\": \"G\",\n    \"year\": \"yY\",\n    \"quarter\": \"qQ\",\n    \"month\": \"ML\",\n    \"week\": \"wW\",\n    \"day\": \"dDF\",\n    \"weekday\": \"ecE\",\n    \"dayperiod\": \"a\",\n    \"hour\": \"hHkK\",\n    \"minute\": \"m\",\n    \"second\": \"sSA\",\n    \"zone\": \"zvVOxX\"\n  }, function (object, key, value) {\n    value.split(\"\").forEach(function (symbol) {\n      object[symbol] = key;\n    });\n    return object;\n  });\n  /**\n   * millisecondsInDay\n   */\n\n  var dateMillisecondsInDay = function (date) {\n    // TODO Handle daylight savings discontinuities\n    return date - dateStartOf(date, \"day\");\n  };\n  /**\n   * hourFormat( date, format, timeSeparator, formatNumber )\n   *\n   * Return date's timezone offset according to the format passed.\n   * Eg for format when timezone offset is 180:\n   * - \"+H;-H\": -3\n   * - \"+HHmm;-HHmm\": -0300\n   * - \"+HH:mm;-HH:mm\": -03:00\n   * - \"+HH:mm:ss;-HH:mm:ss\": -03:00:00\n   */\n\n\n  var dateTimezoneHourFormat = function (date, format, timeSeparator, formatNumber) {\n    var absOffset,\n        offset = date.getTimezoneOffset();\n    absOffset = Math.abs(offset);\n    formatNumber = formatNumber || {\n      1: function (value) {\n        return stringPad(value, 1);\n      },\n      2: function (value) {\n        return stringPad(value, 2);\n      }\n    };\n    return format // Pick the correct sign side (+ or -).\n    .split(\";\")[offset > 0 ? 1 : 0] // Localize time separator\n    .replace(\":\", timeSeparator) // Update hours offset.\n    .replace(/HH?/, function (match) {\n      return formatNumber[match.length](Math.floor(absOffset / 60));\n    }) // Update minutes offset and return.\n    .replace(/mm/, function () {\n      return formatNumber[2](Math.floor(absOffset % 60));\n    }) // Update minutes offset and return.\n    .replace(/ss/, function () {\n      return formatNumber[2](Math.floor(absOffset % 1 * 60));\n    });\n  };\n  /**\n   * format( date, properties )\n   *\n   * @date [Date instance].\n   *\n   * @properties\n   *\n   * TODO Support other calendar types.\n   *\n   * Disclosure: this function borrows excerpts of dojo/date/locale.\n   */\n\n\n  var dateFormat = function (date, numberFormatters, properties) {\n    var parts = [];\n    var timeSeparator = properties.timeSeparator; // create globalize date with given timezone data\n\n    if (properties.timeZoneData) {\n      date = new ZonedDateTime(date, properties.timeZoneData());\n    }\n\n    properties.pattern.replace(datePatternRe, function (current) {\n      var aux,\n          dateField,\n          type,\n          value,\n          chr = current.charAt(0),\n          length = current.length;\n\n      if (chr === \"j\") {\n        // Locale preferred hHKk.\n        // http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n        chr = properties.preferredTime;\n      }\n\n      if (chr === \"Z\") {\n        // Z..ZZZ: same as \"xxxx\".\n        if (length < 4) {\n          chr = \"x\";\n          length = 4; // ZZZZ: same as \"OOOO\".\n        } else if (length < 5) {\n          chr = \"O\";\n          length = 4; // ZZZZZ: same as \"XXXXX\"\n        } else {\n          chr = \"X\";\n          length = 5;\n        }\n      } // z...zzz: \"{shortRegion}\", e.g., \"PST\" or \"PDT\".\n      // zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n      //       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n\n\n      if (chr === \"z\") {\n        if (date.isDST) {\n          value = date.isDST() ? properties.daylightTzName : properties.standardTzName;\n        } // Fall back to \"O\" format.\n\n\n        if (!value) {\n          chr = \"O\";\n\n          if (length < 4) {\n            length = 1;\n          }\n        }\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          value = properties.eras[date.getFullYear() < 0 ? 0 : 1];\n          break;\n        // Year\n\n        case \"y\":\n          // Plain year.\n          // The length specifies the padding, but for two letters it also specifies the\n          // maximum length.\n          value = date.getFullYear();\n\n          if (length === 2) {\n            value = String(value);\n            value = +value.substr(value.length - 2);\n          }\n\n          break;\n\n        case \"Y\":\n          // Year in \"Week of Year\"\n          // The length specifies the padding, but for two letters it also specifies the\n          // maximum length.\n          // yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays\n          value = new Date(date.getTime());\n          value.setDate(value.getDate() + 7 - dateDayOfWeek(date, properties.firstDay) - properties.firstDay - properties.minDays);\n          value = value.getFullYear();\n\n          if (length === 2) {\n            value = String(value);\n            value = +value.substr(value.length - 2);\n          }\n\n          break;\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          value = Math.ceil((date.getMonth() + 1) / 3);\n\n          if (length > 2) {\n            value = properties.quarters[chr][length][value];\n          }\n\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          value = date.getMonth() + 1;\n\n          if (length > 2) {\n            value = properties.months[chr][length][value];\n          }\n\n          break;\n        // Week\n\n        case \"w\":\n          // Week of Year.\n          // woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.\n          // TODO should pad on ww? Not documented, but I guess so.\n          value = dateDayOfWeek(dateStartOf(date, \"year\"), properties.firstDay);\n          value = Math.ceil((dateDayOfYear(date) + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);\n          break;\n\n        case \"W\":\n          // Week of Month.\n          // wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.\n          value = dateDayOfWeek(dateStartOf(date, \"month\"), properties.firstDay);\n          value = Math.ceil((date.getDate() + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);\n          break;\n        // Day\n\n        case \"d\":\n          value = date.getDate();\n          break;\n\n        case \"D\":\n          value = dateDayOfYear(date) + 1;\n          break;\n\n        case \"F\":\n          // Day of Week in month. eg. 2nd Wed in July.\n          value = Math.floor(date.getDate() / 7) + 1;\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          if (length <= 2) {\n            // Range is [1-7] (deduced by example provided on documentation)\n            // TODO Should pad with zeros (not specified in the docs)?\n            value = dateDayOfWeek(date, properties.firstDay) + 1;\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          value = dateWeekDays[date.getDay()];\n          value = properties.days[chr][length][value];\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          value = properties.dayPeriods[date.getHours() < 12 ? \"am\" : \"pm\"];\n          break;\n        // Hour\n\n        case \"h\":\n          // 1-12\n          value = date.getHours() % 12 || 12;\n          break;\n\n        case \"H\":\n          // 0-23\n          value = date.getHours();\n          break;\n\n        case \"K\":\n          // 0-11\n          value = date.getHours() % 12;\n          break;\n\n        case \"k\":\n          // 1-24\n          value = date.getHours() || 24;\n          break;\n        // Minute\n\n        case \"m\":\n          value = date.getMinutes();\n          break;\n        // Second\n\n        case \"s\":\n          value = date.getSeconds();\n          break;\n\n        case \"S\":\n          value = Math.round(date.getMilliseconds() * Math.pow(10, length - 3));\n          break;\n\n        case \"A\":\n          value = Math.round(dateMillisecondsInDay(date) * Math.pow(10, length - 3));\n          break;\n        // Zone\n\n        case \"z\":\n          break;\n\n        case \"v\":\n          // v...vvv: \"{shortRegion}\", eg. \"PT\".\n          // vvvv: \"{regionName} {Time}\",\n          //       e.g., \"Pacific Time\".\n          if (properties.genericTzName) {\n            value = properties.genericTzName;\n            break;\n          }\n\n        /* falls through */\n\n        case \"V\":\n          //VVVV: \"{explarCity} {Time}\", e.g., \"Los Angeles Time\"\n          if (properties.timeZoneName) {\n            value = properties.timeZoneName;\n            break;\n          }\n\n          if (current === \"v\") {\n            length = 1;\n          }\n\n        /* falls through */\n\n        case \"O\":\n          // O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n          // OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n          if (date.getTimezoneOffset() === 0) {\n            value = properties.gmtZeroFormat;\n          } else {\n            // If O..OOO and timezone offset has non-zero minutes, show minutes.\n            if (length < 4) {\n              aux = date.getTimezoneOffset();\n              aux = properties.hourFormat[aux % 60 - aux % 1 === 0 ? 0 : 1];\n            } else {\n              aux = properties.hourFormat;\n            }\n\n            value = dateTimezoneHourFormat(date, aux, timeSeparator, numberFormatters);\n            value = properties.gmtFormat.replace(/\\{0\\}/, value);\n          }\n\n          break;\n\n        case \"X\":\n          // Same as x*, except it uses \"Z\" for zero offset.\n          if (date.getTimezoneOffset() === 0) {\n            value = \"Z\";\n            break;\n          }\n\n        /* falls through */\n\n        case \"x\":\n          // x: hourFormat(\"+HH[mm];-HH[mm]\")\n          // xx: hourFormat(\"+HHmm;-HHmm\")\n          // xxx: hourFormat(\"+HH:mm;-HH:mm\")\n          // xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n          // xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n          aux = date.getTimezoneOffset(); // If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).\n\n          if (length === 1 && aux % 60 - aux % 1 !== 0) {\n            length += 1;\n          } // If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx\n          // respectively (i.e., don't show optional seconds).\n\n\n          if ((length === 4 || length === 5) && aux % 1 === 0) {\n            length -= 2;\n          }\n\n          value = [\"+HH;-HH\", \"+HHmm;-HHmm\", \"+HH:mm;-HH:mm\", \"+HHmmss;-HHmmss\", \"+HH:mm:ss;-HH:mm:ss\"][length - 1];\n          value = dateTimezoneHourFormat(date, value, \":\");\n          break;\n        // timeSeparator\n\n        case \":\":\n          value = timeSeparator;\n          break;\n        // ' literals.\n\n        case \"'\":\n          value = removeLiteralQuotes(current);\n          break;\n        // Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and\n        // arabic characters.\n\n        default:\n          value = current;\n      }\n\n      if (typeof value === \"number\") {\n        value = numberFormatters[length](value);\n      }\n\n      dateField = dateFieldsMap[chr];\n      type = dateField ? dateField : \"literal\"; // Concat two consecutive literals\n\n      if (type === \"literal\" && parts.length && parts[parts.length - 1].type === \"literal\") {\n        parts[parts.length - 1].value += value;\n        return;\n      }\n\n      parts.push({\n        type: type,\n        value: value\n      });\n    });\n    return parts;\n  };\n\n  var dateToPartsFormatterFn = function (numberFormatters, properties) {\n    return function dateToPartsFormatter(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeDate(value, \"value\");\n      return dateFormat(value, numberFormatters, properties);\n    };\n  };\n\n  function optionsHasStyle(options) {\n    return options.skeleton !== undefined || options.date !== undefined || options.time !== undefined || options.datetime !== undefined || options.raw !== undefined;\n  }\n\n  function validateRequiredCldr(path, value) {\n    validateCldr(path, value, {\n      skip: [/dates\\/calendars\\/gregorian\\/dateTimeFormats\\/availableFormats/, /dates\\/calendars\\/gregorian\\/days\\/.*\\/short/, /dates\\/timeZoneNames\\/zone/, /dates\\/timeZoneNames\\/metazone/, /globalize-iana/, /supplemental\\/metaZones/, /supplemental\\/timeData\\/(?!001)/, /supplemental\\/weekData\\/(?!001)/]\n    });\n  }\n\n  function validateOptionsPreset(options) {\n    validateOptionsPresetEach(\"date\", options);\n    validateOptionsPresetEach(\"time\", options);\n    validateOptionsPresetEach(\"datetime\", options);\n  }\n\n  function validateOptionsPresetEach(type, options) {\n    var value = options[type];\n    validate(\"E_INVALID_OPTIONS\", \"Invalid `{{type}: \\\"{value}\\\"}`.\", value === undefined || [\"short\", \"medium\", \"long\", \"full\"].indexOf(value) !== -1, {\n      type: type,\n      value: value\n    });\n  }\n\n  function validateOptionsSkeleton(pattern, skeleton) {\n    validate(\"E_INVALID_OPTIONS\", \"Invalid `{skeleton: \\\"{value}\\\"}` based on provided CLDR.\", skeleton === undefined || typeof pattern === \"string\" && pattern, {\n      type: \"skeleton\",\n      value: skeleton\n    });\n  }\n\n  function validateRequiredIana(timeZone) {\n    return function (path, value) {\n      if (!/globalize-iana/.test(path)) {\n        return;\n      }\n\n      validate(\"E_MISSING_IANA_TZ\", \"Missing required IANA timezone content for `{timeZone}`: `{path}`.\", value, {\n        path: path.replace(/globalize-iana\\//, \"\"),\n        timeZone: timeZone\n      });\n    };\n  }\n  /**\n   * .loadTimeZone( json )\n   *\n   * @json [JSON]\n   *\n   * Load IANA timezone data.\n   */\n\n\n  Globalize.loadTimeZone = function (json) {\n    var customData = {\n      \"globalize-iana\": json\n    };\n    validateParameterPresence(json, \"json\");\n    validateParameterTypePlainObject(json, \"json\");\n    Cldr.load(customData);\n  };\n  /**\n   * .dateFormatter( options )\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Return a date formatter function (of the form below) according to the given options and the\n   * default/instance locale.\n   *\n   * fn( value )\n   *\n   * @value [Date]\n   *\n   * Return a function that formats a date according to the given `format` and the default/instance\n   * locale.\n   */\n\n\n  Globalize.dateFormatter = Globalize.prototype.dateFormatter = function (options) {\n    var args, dateToPartsFormatter, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    args = [options];\n    dateToPartsFormatter = this.dateToPartsFormatter(options);\n    returnFn = dateFormatterFn(dateToPartsFormatter);\n    runtimeBind(args, this.cldr, returnFn, [dateToPartsFormatter]);\n    return returnFn;\n  };\n  /**\n   * .dateToPartsFormatter( options )\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Return a date formatter function (of the form below) according to the given options and the\n   * default/instance locale.\n   *\n   * fn( value )\n   *\n   * @value [Date]\n   *\n   * Return a function that formats a date to parts according to the given `format`\n   * and the default/instance\n   * locale.\n   */\n\n\n  Globalize.dateToPartsFormatter = Globalize.prototype.dateToPartsFormatter = function (options) {\n    var args, cldr, numberFormatters, pad, pattern, properties, returnFn, timeZone, ianaListener;\n    validateParameterTypePlainObject(options, \"options\");\n    cldr = this.cldr;\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    validateOptionsPreset(options);\n    validateDefaultLocale(cldr);\n    timeZone = options.timeZone;\n    validateParameterTypeString(timeZone, \"options.timeZone\");\n    args = [options];\n    cldr.on(\"get\", validateRequiredCldr);\n\n    if (timeZone) {\n      ianaListener = validateRequiredIana(timeZone);\n      cldr.on(\"get\", ianaListener);\n    }\n\n    pattern = dateExpandPattern(options, cldr);\n    validateOptionsSkeleton(pattern, options.skeleton);\n    properties = dateFormatProperties(pattern, cldr, timeZone);\n    cldr.off(\"get\", validateRequiredCldr);\n\n    if (ianaListener) {\n      cldr.off(\"get\", ianaListener);\n    } // Create needed number formatters.\n\n\n    numberFormatters = properties.numberFormatters;\n    delete properties.numberFormatters;\n\n    for (pad in numberFormatters) {\n      numberFormatters[pad] = this.numberFormatter({\n        raw: numberFormatters[pad]\n      });\n    }\n\n    returnFn = dateToPartsFormatterFn(numberFormatters, properties);\n    runtimeBind(args, cldr, returnFn, [numberFormatters, properties]);\n    return returnFn;\n  };\n  /**\n   * .dateParser( options )\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Return a function that parses a string date according to the given `formats` and the\n   * default/instance locale.\n   */\n\n\n  Globalize.dateParser = Globalize.prototype.dateParser = function (options) {\n    var args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone, tokenizerProperties;\n    validateParameterTypePlainObject(options, \"options\");\n    cldr = this.cldr;\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    validateOptionsPreset(options);\n    validateDefaultLocale(cldr);\n    timeZone = options.timeZone;\n    validateParameterTypeString(timeZone, \"options.timeZone\");\n    args = [options];\n    cldr.on(\"get\", validateRequiredCldr);\n\n    if (timeZone) {\n      cldr.on(\"get\", validateRequiredIana(timeZone));\n    }\n\n    pattern = dateExpandPattern(options, cldr);\n    validateOptionsSkeleton(pattern, options.skeleton);\n    tokenizerProperties = dateTokenizerProperties(pattern, cldr, timeZone);\n    parseProperties = dateParseProperties(cldr, timeZone);\n    cldr.off(\"get\", validateRequiredCldr);\n\n    if (timeZone) {\n      cldr.off(\"get\", validateRequiredIana(timeZone));\n    }\n\n    numberParser = this.numberParser({\n      raw: \"0\"\n    });\n    returnFn = dateParserFn(numberParser, parseProperties, tokenizerProperties);\n    runtimeBind(args, cldr, returnFn, [numberParser, parseProperties, tokenizerProperties]);\n    return returnFn;\n  };\n  /**\n   * .formatDate( value, options )\n   *\n   * @value [Date]\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Formats a date or number according to the given options string and the default/instance locale.\n   */\n\n\n  Globalize.formatDate = Globalize.prototype.formatDate = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeDate(value, \"value\");\n    return this.dateFormatter(options)(value);\n  };\n  /**\n   * .formatDateToParts( value, options )\n   *\n   * @value [Date]\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Formats a date or number to parts according to the given options and the default/instance locale.\n   */\n\n\n  Globalize.formatDateToParts = Globalize.prototype.formatDateToParts = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeDate(value, \"value\");\n    return this.dateToPartsFormatter(options)(value);\n  };\n  /**\n   * .parseDate( value, options )\n   *\n   * @value [String]\n   *\n   * @options [Object] see date/expand_pattern for more info.\n   *\n   * Return a Date instance or null.\n   */\n\n\n  Globalize.parseDate = Globalize.prototype.parseDate = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeString(value, \"value\");\n    return this.dateParser(options)(value);\n  };\n\n  return Globalize;\n});","map":null,"metadata":{},"sourceType":"script"}