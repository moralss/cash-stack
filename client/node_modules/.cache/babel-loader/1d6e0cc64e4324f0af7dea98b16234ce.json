{"ast":null,"code":"/**\n * Globalize v1.4.2\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2019-03-07T13:47Z\n */\n\n/*!\n * Globalize v1.4.2 2019-03-07T13:47Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  // UMD returnExports\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"cldr\", \"../globalize\", \"cldr/event\", \"cldr/supplemental\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"cldrjs\"), require(\"../globalize\"));\n  } else {\n    // Global\n    factory(root.Cldr, root.Globalize);\n  }\n})(this, function (Cldr, Globalize) {\n  var createError = Globalize._createError,\n      regexpEscape = Globalize._regexpEscape,\n      runtimeBind = Globalize._runtimeBind,\n      stringPad = Globalize._stringPad,\n      validateCldr = Globalize._validateCldr,\n      validateDefaultLocale = Globalize._validateDefaultLocale,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterRange = Globalize._validateParameterRange,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n\n  var createErrorUnsupportedFeature = function (feature) {\n    return createError(\"E_UNSUPPORTED\", \"Unsupported {feature}.\", {\n      feature: feature\n    });\n  };\n\n  var validateParameterTypeNumber = function (value, name) {\n    validateParameterType(value, name, value === undefined || typeof value === \"number\", \"Number\");\n  };\n\n  var validateParameterTypeString = function (value, name) {\n    validateParameterType(value, name, value === undefined || typeof value === \"string\", \"a string\");\n  };\n  /**\n   * EBNF representation:\n   *\n   * compact_pattern_re =       prefix?\n   *                            number_pattern_re\n   *                            suffix?\n   *\n   * number_pattern_re =        0+\n   *\n   * Regexp groups:\n   *\n   *  0: compact_pattern_re\n   *  1: prefix\n   *  2: number_pattern_re (the number pattern to use in compact mode)\n   *  3: suffix\n   */\n\n\n  var numberCompactPatternRe = /^([^0]*)(0+)([^0]*)$/;\n  /**\n   * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\n   *\n   * @number [Number].\n   *\n   * @primaryGroupingSize [Number]\n   *\n   * @secondaryGroupingSize [Number]\n   *\n   * Return the formatted number with group separator.\n   */\n\n  var numberFormatGroupingSeparator = function (number, primaryGroupingSize, secondaryGroupingSize) {\n    var index,\n        currentGroupingSize = primaryGroupingSize,\n        ret = \"\",\n        sep = \",\",\n        switchToSecondary = secondaryGroupingSize ? true : false;\n    number = String(number).split(\".\");\n    index = number[0].length;\n\n    while (index > currentGroupingSize) {\n      ret = number[0].slice(index - currentGroupingSize, index) + (ret.length ? sep : \"\") + ret;\n      index -= currentGroupingSize;\n\n      if (switchToSecondary) {\n        currentGroupingSize = secondaryGroupingSize;\n        switchToSecondary = false;\n      }\n    }\n\n    number[0] = number[0].slice(0, index) + (ret.length ? sep : \"\") + ret;\n    return number.join(\".\");\n  };\n  /**\n   * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\n   * maximumFractionDigits, round, roundIncrement )\n   *\n   * @number [Number]\n   *\n   * @minimumIntegerDigits [Number]\n   *\n   * @minimumFractionDigits [Number]\n   *\n   * @maximumFractionDigits [Number]\n   *\n   * @round [Function]\n   *\n   * @roundIncrement [Function]\n   *\n   * Return the formatted integer and fraction digits.\n   */\n\n\n  var numberFormatIntegerFractionDigits = function (number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement) {\n    // Fraction\n    if (maximumFractionDigits) {\n      // Rounding\n      if (roundIncrement) {\n        number = round(number, roundIncrement); // Maximum fraction digits\n      } else {\n        number = round(number, {\n          exponent: -maximumFractionDigits\n        });\n      }\n    } else {\n      number = round(number);\n    }\n\n    number = String(number); // Maximum integer digits (post string phase)\n\n    if (maximumFractionDigits && /e-/.test(number)) {\n      // Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are\n      // displayed using plain digits instead of scientific notation.\n      // 1: Remove leading decimal zeros.\n      // 2: Remove leading decimal separator.\n      // Note: String() is still preferred so it doesn't mess up with a number precision\n      // unnecessarily, e.g., (123456789.123).toFixed(10) === \"123456789.1229999959\",\n      // String(123456789.123) === \"123456789.123\".\n      number = (+number).toFixed(maximumFractionDigits).replace(/0+$/, \"\")\n      /* 1 */\n      .replace(/\\.$/, \"\")\n      /* 2 */\n      ;\n    } // Minimum fraction digits (post string phase)\n\n\n    if (minimumFractionDigits) {\n      number = number.split(\".\");\n      number[1] = stringPad(number[1] || \"\", minimumFractionDigits, true);\n      number = number.join(\".\");\n    } // Minimum integer digits\n\n\n    if (minimumIntegerDigits) {\n      number = number.split(\".\");\n      number[0] = stringPad(number[0], minimumIntegerDigits);\n      number = number.join(\".\");\n    }\n\n    return number;\n  };\n  /**\n   * toPrecision( number, precision, round )\n   *\n   * @number (Number)\n   *\n   * @precision (Number) significant figures precision (not decimal precision).\n   *\n   * @round (Function)\n   *\n   * Return number.toPrecision( precision ) using the given round function.\n   */\n\n\n  var numberToPrecision = function (number, precision, round) {\n    var roundOrder;\n    roundOrder = Math.ceil(Math.log(Math.abs(number)) / Math.log(10));\n    roundOrder -= precision;\n    return round(number, {\n      exponent: roundOrder\n    });\n  };\n  /**\n   * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\n   *\n   * @number [Number]\n   *\n   * @minimumSignificantDigits [Number]\n   *\n   * @maximumSignificantDigits [Number]\n   *\n   * @round [Function]\n   *\n   * Return the formatted significant digits number.\n   */\n\n\n  var numberFormatSignificantDigits = function (number, minimumSignificantDigits, maximumSignificantDigits, round) {\n    var atMinimum, atMaximum; // Sanity check.\n\n    if (minimumSignificantDigits > maximumSignificantDigits) {\n      maximumSignificantDigits = minimumSignificantDigits;\n    }\n\n    atMinimum = numberToPrecision(number, minimumSignificantDigits, round);\n    atMaximum = numberToPrecision(number, maximumSignificantDigits, round); // Use atMaximum only if it has more significant digits than atMinimum.\n\n    number = +atMinimum === +atMaximum ? atMinimum : atMaximum; // Expand integer numbers, eg. 123e5 to 12300.\n\n    number = (+number).toString(10);\n\n    if (/e/.test(number)) {\n      throw createErrorUnsupportedFeature({\n        feature: \"integers out of (1e21, 1e-7)\"\n      });\n    } // Add trailing zeros if necessary.\n\n\n    if (minimumSignificantDigits - number.replace(/^0+|\\./g, \"\").length > 0) {\n      number = number.split(\".\");\n      number[1] = stringPad(number[1] || \"\", minimumSignificantDigits - number[0].replace(/^0+/, \"\").length, true);\n      number = number.join(\".\");\n    }\n\n    return number;\n  };\n  /**\n   * EBNF representation:\n   *\n   * number_pattern_re =        prefix?\n   *                            padding?\n   *                            (integer_fraction_pattern | significant_pattern)\n   *                            scientific_notation?\n   *                            suffix?\n   *\n   * prefix =                   non_number_stuff\n   *\n   * padding =                  \"*\" regexp(.)\n   *\n   * integer_fraction_pattern = integer_pattern\n   *                            fraction_pattern?\n   *\n   * integer_pattern =          regexp([#,]*[0,]*0+)\n   *\n   * fraction_pattern =         \".\" regexp(0*[0-9]*#*)\n   *\n   * significant_pattern =      regexp([#,]*@+#*)\n   *\n   * scientific_notation =      regexp(E\\+?0+)\n   *\n   * suffix =                   non_number_stuff\n   *\n   * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)\n   *\n   *\n   * Regexp groups:\n   *\n   *  0: number_pattern_re\n   *  1: prefix\n   *  2: -\n   *  3: -\n   *  4: padding\n   *  5: (integer_fraction_pattern | significant_pattern)\n   *  6: integer_fraction_pattern\n   *  7: integer_pattern\n   *  8: fraction_pattern\n   *  9: significant_pattern\n   * 10: scientific_notation\n   * 11: suffix\n   * 12: -\n   */\n\n\n  var numberPatternRe = /^(('([^']|'')*'|[^*#@0,.E])*)(\\*.)?((([#,]*[0,]*0+)(\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;\n  /**\n   * removeLiteralQuotes( string )\n   *\n   * Return:\n   * - `` if input string is `''`.\n   * - `o'clock` if input string is `'o''clock'`.\n   * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted\n   *   string.\n   */\n\n  var removeLiteralQuotes = function (string) {\n    if (string[0] + string[string.length - 1] !== \"''\") {\n      return string;\n    }\n\n    if (string === \"''\") {\n      return \"\";\n    }\n\n    return string.replace(/''/g, \"'\").slice(1, -1);\n  };\n  /**\n   * format( number, properties )\n   *\n   * @number [Number].\n   *\n   * @properties [Object] Output of number/format-properties.\n   *\n   * Return the formatted number.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberFormat = function (number, properties, pluralGenerator) {\n    var compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix, primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix, symbolMap;\n    padding = properties[1];\n    minimumIntegerDigits = properties[2];\n    minimumFractionDigits = properties[3];\n    maximumFractionDigits = properties[4];\n    minimumSignificantDigits = properties[5];\n    maximumSignificantDigits = properties[6];\n    roundIncrement = properties[7];\n    primaryGroupingSize = properties[8];\n    secondaryGroupingSize = properties[9];\n    round = properties[15];\n    infinitySymbol = properties[16];\n    nanSymbol = properties[17];\n    symbolMap = properties[18];\n    nuDigitsMap = properties[19];\n    compactMap = properties[20]; // NaN\n\n    if (isNaN(number)) {\n      return nanSymbol;\n    }\n\n    if (number < 0) {\n      pattern = properties[12];\n      prefix = properties[13];\n      suffix = properties[14];\n    } else {\n      pattern = properties[11];\n      prefix = properties[0];\n      suffix = properties[10];\n    } // Infinity\n\n\n    if (!isFinite(number)) {\n      return prefix + infinitySymbol + suffix;\n    } // Percent\n\n\n    if (pattern.indexOf(\"%\") !== -1) {\n      number *= 100; // Per mille\n    } else if (pattern.indexOf(\"\\u2030\") !== -1) {\n      number *= 1000;\n    }\n\n    var compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm; // Compact mode: initial number digit processing\n\n    if (compactMap) {\n      numberExponent = Math.abs(Math.floor(number)).toString().length - 1;\n      numberExponent = Math.min(numberExponent, compactMap.maxExponent); // Use default plural form to perform initial decimal shift\n\n      if (numberExponent >= 3) {\n        compactPattern = compactMap[numberExponent] && compactMap[numberExponent].other;\n      }\n\n      if (compactPattern === \"0\") {\n        compactPattern = null;\n      } else if (compactPattern) {\n        compactDigits = compactPattern.split(\"0\").length - 1;\n        divisor = numberExponent - (compactDigits - 1);\n        number = number / Math.pow(10, divisor);\n      }\n    } // Significant digit format\n\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {\n      number = numberFormatSignificantDigits(number, minimumSignificantDigits, maximumSignificantDigits, round); // Integer and fractional format\n    } else {\n      number = numberFormatIntegerFractionDigits(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement);\n    } // Compact mode: apply formatting\n\n\n    if (compactMap && compactPattern) {\n      // Get plural form after possible roundings\n      pluralForm = pluralGenerator ? pluralGenerator(+number) : \"other\";\n      compactPattern = compactMap[numberExponent][pluralForm] || compactPattern;\n      compactProperties = compactPattern.match(numberCompactPatternRe); // update prefix/suffix with compact prefix/suffix\n\n      prefix += compactProperties[1];\n      suffix = compactProperties[3] + suffix;\n    } // Remove the possible number minus sign\n\n\n    number = number.replace(/^-/, \"\"); // Grouping separators\n\n    if (primaryGroupingSize) {\n      number = numberFormatGroupingSeparator(number, primaryGroupingSize, secondaryGroupingSize);\n    }\n\n    ret = prefix;\n    ret += number; // Scientific notation\n    // TODO implement here\n    // Padding/'([^']|'')+'|''|[.,\\-+E%\\u2030]/g\n    // TODO implement here\n\n    ret += suffix;\n    return ret.replace(/('([^']|'')+'|'')|./g, function (character, literal) {\n      // Literals\n      if (literal) {\n        return removeLiteralQuotes(literal);\n      } // Symbols\n\n\n      character = character.replace(/[.,\\-+E%\\u2030]/, function (symbol) {\n        return symbolMap[symbol];\n      }); // Numbering system\n\n      if (nuDigitsMap) {\n        character = character.replace(/[0-9]/, function (digit) {\n          return nuDigitsMap[+digit];\n        });\n      }\n\n      return character;\n    });\n  };\n\n  var numberFormatterFn = function (properties, pluralGenerator) {\n    return function numberFormatter(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeNumber(value, \"value\");\n      return numberFormat(value, properties, pluralGenerator);\n    };\n  };\n  /**\n   * NumberingSystem( cldr )\n   *\n   * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems\n   * - http://cldr.unicode.org/index/bcp47-extension\n   * - http://www.unicode.org/reports/tr35/#u_Extension\n   */\n\n\n  var numberNumberingSystem = function (cldr) {\n    var nu = cldr.attributes[\"u-nu\"];\n\n    if (nu) {\n      if (nu === \"traditio\") {\n        nu = \"traditional\";\n      }\n\n      if ([\"native\", \"traditional\", \"finance\"].indexOf(nu) !== -1) {\n        // Unicode locale extension `u-nu` is set using either (native, traditional or\n        // finance). So, lookup the respective locale's numberingSystem and return it.\n        return cldr.main([\"numbers/otherNumberingSystems\", nu]);\n      } // Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.\n\n\n      return nu;\n    } // Return the default numberingSystem.\n\n\n    return cldr.main(\"numbers/defaultNumberingSystem\");\n  };\n  /**\n   * Compact( name, cldr )\n   *\n   * @compactType [String] Compact mode, `short` or `long`.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the localized compact map for the given compact mode.\n   */\n\n\n  var numberCompact = function (compactType, cldr) {\n    var maxExponent = 0;\n    var object = cldr.main([\"numbers/decimalFormats-numberSystem-\" + numberNumberingSystem(cldr), compactType, \"decimalFormat\"]);\n    object = Object.keys(object).reduce(function (newObject, compactKey) {\n      var numberExponent = compactKey.split(\"0\").length - 1;\n      var pluralForm = compactKey.split(\"-\")[2];\n      newObject[numberExponent] = newObject[numberExponent] || {};\n      newObject[numberExponent][pluralForm] = object[compactKey];\n      maxExponent = Math.max(numberExponent, maxExponent);\n      return newObject;\n    }, {});\n    object.maxExponent = maxExponent;\n    return object;\n  };\n  /**\n   * nuMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return digits map if numbering system is different than `latn`.\n   */\n\n\n  var numberNumberingSystemDigitsMap = function (cldr) {\n    var aux,\n        nu = numberNumberingSystem(cldr);\n\n    if (nu === \"latn\") {\n      return;\n    }\n\n    aux = cldr.supplemental([\"numberingSystems\", nu]);\n\n    if (aux._type !== \"numeric\") {\n      throw createErrorUnsupportedFeature(\"`\" + aux._type + \"` numbering system\");\n    }\n\n    return aux._digits;\n  };\n  /**\n   * format( number, pattern )\n   *\n   * @number [Number].\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * Return the formatted number.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberPatternProperties = function (pattern) {\n    var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize, roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;\n    pattern = pattern.match(numberPatternRe);\n\n    if (!pattern) {\n      throw new Error(\"Invalid pattern: \" + pattern);\n    }\n\n    prefix = pattern[1];\n    padding = pattern[4];\n    integerFractionOrSignificantPattern = pattern[5];\n    significantPattern = pattern[9];\n    scientificNotation = pattern[10];\n    suffix = pattern[11]; // Significant digit format\n\n    if (significantPattern) {\n      significantPattern.replace(/(@+)(#*)/, function (match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch) {\n        minimumSignificantDigits = minimumSignificantDigitsMatch.length;\n        maximumSignificantDigits = minimumSignificantDigits + maximumSignificantDigitsMatch.length;\n      }); // Integer and fractional format\n    } else {\n      fractionPattern = pattern[8];\n      integerPattern = pattern[7];\n\n      if (fractionPattern) {\n        // Minimum fraction digits, and rounding.\n        fractionPattern.replace(/[0-9]+/, function (match) {\n          minimumFractionDigits = match;\n        });\n\n        if (minimumFractionDigits) {\n          roundIncrement = +(\"0.\" + minimumFractionDigits);\n          minimumFractionDigits = minimumFractionDigits.length;\n        } else {\n          minimumFractionDigits = 0;\n        } // Maximum fraction digits\n        // 1: ignore decimal character\n\n\n        maximumFractionDigits = fractionPattern.length - 1\n        /* 1 */\n        ;\n      } else {\n        minimumFractionDigits = 0;\n        maximumFractionDigits = 0;\n      } // Minimum integer digits\n\n\n      integerPattern.replace(/0+$/, function (match) {\n        minimumIntegerDigits = match.length;\n      });\n    } // Scientific notation\n\n\n    if (scientificNotation) {\n      throw createErrorUnsupportedFeature({\n        feature: \"scientific notation (not implemented)\"\n      });\n    } // Padding\n\n\n    if (padding) {\n      throw createErrorUnsupportedFeature({\n        feature: \"padding (not implemented)\"\n      });\n    } // Grouping\n\n\n    if ((aux1 = integerFractionOrSignificantPattern.lastIndexOf(\",\")) !== -1) {\n      // Primary grouping size is the interval between the last group separator and the end of\n      // the integer (or the end of the significant pattern).\n      aux2 = integerFractionOrSignificantPattern.split(\".\")[0];\n      primaryGroupingSize = aux2.length - aux1 - 1; // Secondary grouping size is the interval between the last two group separators.\n\n      if ((aux2 = integerFractionOrSignificantPattern.lastIndexOf(\",\", aux1 - 1)) !== -1) {\n        secondaryGroupingSize = aux1 - 1 - aux2;\n      }\n    } // Return:\n    //  0: @prefix String\n    //  1: @padding Array [ <character>, <count> ] TODO\n    //  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer\n    //        digits to be used. Numbers will be padded with leading zeroes if necessary.\n    //  3: @minimumFractionDigits and\n    //  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and\n    //        maximum fraction digits to be used. Numbers will be rounded or padded with trailing\n    //        zeroes if necessary.\n    //  5: @minimumSignificantDigits and\n    //  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and\n    //        maximum fraction digits to be shown. Either none or both of these properties are\n    //        present; if they are, they override minimum and maximum integer and fraction digits\n    //        – the formatter uses however many integer and fraction digits are required to display\n    //        the specified number of significant digits.\n    //  7: @roundIncrement Decimal round increment or null\n    //  8: @primaryGroupingSize\n    //  9: @secondaryGroupingSize\n    // 10: @suffix String\n\n\n    return [prefix, padding, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, roundIncrement, primaryGroupingSize, secondaryGroupingSize, suffix];\n  };\n  /**\n   * Symbol( name, cldr )\n   *\n   * @name [String] Symbol name.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the localized symbol given its name.\n   */\n\n\n  var numberSymbol = function (name, cldr) {\n    return cldr.main([\"numbers/symbols-numberSystem-\" + numberNumberingSystem(cldr), name]);\n  };\n\n  var numberSymbolName = {\n    \".\": \"decimal\",\n    \",\": \"group\",\n    \"%\": \"percentSign\",\n    \"+\": \"plusSign\",\n    \"-\": \"minusSign\",\n    \"E\": \"exponential\",\n    \"\\u2030\": \"perMille\"\n  };\n  /**\n   * symbolMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the (localized symbol, pattern symbol) key value pair, eg. {\n   *   \".\": \"٫\",\n   *   \",\": \"٬\",\n   *   \"%\": \"٪\",\n   *   ...\n   * };\n   */\n\n  var numberSymbolMap = function (cldr) {\n    var symbol,\n        symbolMap = {};\n\n    for (symbol in numberSymbolName) {\n      symbolMap[symbol] = numberSymbol(numberSymbolName[symbol], cldr);\n    }\n\n    return symbolMap;\n  };\n\n  var numberTruncate = function (value) {\n    if (isNaN(value)) {\n      return NaN;\n    }\n\n    return Math[value < 0 ? \"ceil\" : \"floor\"](value);\n  };\n  /**\n   * round( method )\n   *\n   * @method [String] with either \"round\", \"ceil\", \"floor\", or \"truncate\".\n   *\n   * Return function( value, incrementOrExp ):\n   *\n   *   @value [Number] eg. 123.45.\n   *\n   *   @incrementOrExp [Number] optional, eg. 0.1; or\n   *     [Object] Either { increment: <value> } or { exponent: <value> }\n   *\n   *   Return the rounded number, eg:\n   *   - round( \"round\" )( 123.45 ): 123;\n   *   - round( \"ceil\" )( 123.45 ): 124;\n   *   - round( \"floor\" )( 123.45 ): 123;\n   *   - round( \"truncate\" )( 123.45 ): 123;\n   *   - round( \"round\" )( 123.45, 0.1 ): 123.5;\n   *   - round( \"round\" )( 123.45, 10 ): 120;\n   *\n   *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n   *   Ref: #376\n   */\n\n\n  var numberRound = function (method) {\n    method = method || \"round\";\n    method = method === \"truncate\" ? numberTruncate : Math[method];\n    return function (value, incrementOrExp) {\n      var exp, increment;\n      value = +value; // If the value is not a number, return NaN.\n\n      if (isNaN(value)) {\n        return NaN;\n      } // Exponent given.\n\n\n      if (typeof incrementOrExp === \"object\" && incrementOrExp.exponent) {\n        exp = +incrementOrExp.exponent;\n        increment = 1;\n\n        if (exp === 0) {\n          return method(value);\n        } // If the exp is not an integer, return NaN.\n\n\n        if (!(typeof exp === \"number\" && exp % 1 === 0)) {\n          return NaN;\n        } // Increment given.\n\n      } else {\n        increment = +incrementOrExp || 1;\n\n        if (increment === 1) {\n          return method(value);\n        } // If the increment is not a number, return NaN.\n\n\n        if (isNaN(increment)) {\n          return NaN;\n        }\n\n        increment = increment.toExponential().split(\"e\");\n        exp = +increment[1];\n        increment = +increment[0];\n      } // Shift & Round\n\n\n      value = value.toString().split(\"e\");\n      value[0] = +value[0] / increment;\n      value[1] = value[1] ? +value[1] - exp : -exp;\n      value = method(+(value[0] + \"e\" + value[1])); // Shift back\n\n      value = value.toString().split(\"e\");\n      value[0] = +value[0] * increment;\n      value[1] = value[1] ? +value[1] + exp : exp;\n      return +(value[0] + \"e\" + value[1]);\n    };\n  };\n  /**\n   * formatProperties( pattern, cldr [, options] )\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * @cldr [Cldr instance].\n   *\n   * @options [Object]:\n   * - minimumIntegerDigits [Number]\n   * - minimumFractionDigits, maximumFractionDigits [Number]\n   * - minimumSignificantDigits, maximumSignificantDigits [Number]\n   * - round [String] \"ceil\", \"floor\", \"round\" (default), or \"truncate\".\n   * - useGrouping [Boolean] default true.\n   *\n   * Return the processed properties that will be used in number/format.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberFormatProperties = function (pattern, cldr, options) {\n    var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern, roundFn, properties;\n\n    function getOptions(attribute, propertyIndex) {\n      if (attribute in options) {\n        properties[propertyIndex] = options[attribute];\n      }\n    }\n\n    options = options || {};\n    pattern = pattern.split(\";\");\n    positivePattern = pattern[0];\n    negativePattern = pattern[1] || \"-\" + positivePattern;\n    negativeProperties = numberPatternProperties(negativePattern);\n    negativePrefix = negativeProperties[0];\n    negativeSuffix = negativeProperties[10]; // Have runtime code to refer to numberRound() instead of including it explicitly.\n\n    roundFn = numberRound(options.round);\n\n    roundFn.generatorString = function () {\n      return \"numberRound(\" + (options.round ? \"\\\"\" + options.round + \"\\\"\" : \"\") + \")\";\n    };\n\n    properties = numberPatternProperties(positivePattern).concat([positivePattern, negativePrefix + positivePattern + negativeSuffix, negativePrefix, negativeSuffix, roundFn, numberSymbol(\"infinity\", cldr), numberSymbol(\"nan\", cldr), numberSymbolMap(cldr), numberNumberingSystemDigitsMap(cldr)]);\n\n    if (options.compact) {\n      // The compact digits number pattern is always `0+`, so override the following properties.\n      // Note: minimumIntegerDigits would actually range from `0` to `000` based on the scale of\n      // the value to be formatted, though we're always using 1 as a simplification, because the\n      // number won't be zero-padded since we chose the right format based on the scale, i.e.,\n      // we'd never see something like `003M` anyway.\n      properties[2] = 1; // minimumIntegerDigits\n\n      properties[3] = 0; // minimumFractionDigits\n\n      properties[4] = 0; // maximumFractionDigits\n\n      properties[5] = // minimumSignificantDigits &\n      properties[6] = undefined; // maximumSignificantDigits\n\n      properties[20] = numberCompact(options.compact, cldr);\n    }\n\n    getOptions(\"minimumIntegerDigits\", 2);\n    getOptions(\"minimumFractionDigits\", 3);\n    getOptions(\"maximumFractionDigits\", 4);\n    getOptions(\"minimumSignificantDigits\", 5);\n    getOptions(\"maximumSignificantDigits\", 6); // Grouping separators\n\n    if (options.useGrouping === false) {\n      properties[8] = null;\n    } // Normalize number of digits if only one of either minimumFractionDigits or\n    // maximumFractionDigits is passed in as an option\n\n\n    if (\"minimumFractionDigits\" in options && !(\"maximumFractionDigits\" in options)) {\n      // maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );\n      properties[4] = Math.max(properties[3], properties[4]);\n    } else if (!(\"minimumFractionDigits\" in options) && \"maximumFractionDigits\" in options) {\n      // minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );\n      properties[3] = Math.min(properties[3], properties[4]);\n    } // Return:\n    // 0-10: see number/pattern-properties.\n    // 11: @positivePattern [String] Positive pattern.\n    // 12: @negativePattern [String] Negative pattern.\n    // 13: @negativePrefix [String] Negative prefix.\n    // 14: @negativeSuffix [String] Negative suffix.\n    // 15: @round [Function] Round function.\n    // 16: @infinitySymbol [String] Infinity symbol.\n    // 17: @nanSymbol [String] NaN symbol.\n    // 18: @symbolMap [Object] A bunch of other symbols.\n    // 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.\n    // 20: @compactMap [Object] Map of per-digit-count format patterns for specified compact mode.\n\n\n    return properties;\n  };\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var formatSymbols = require( * \"unicode-8.0.0/General_Category/Format/symbols\" );\n   * regenerate().add( formatSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   */\n\n\n  var regexpCfG = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/g;\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var dashSymbols = require( * \"unicode-8.0.0/General_Category/Dash_Punctuation/symbols\" );\n   * regenerate().add( dashSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   *\n   * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\n   */\n\n  var regexpDashG = /[\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u2212]/g;\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var spaceSeparatorSymbols = require( \"unicode-8.0.0/General_Category/Space_Separator/symbols\" );\n   * regenerate().add( spaceSeparatorSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   */\n\n  var regexpZsG = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g;\n  /**\n   * Loose Matching:\n   * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n   *   formatting.\n   * - Map all characters in [:Zs:] to U+0020 SPACE;\n   * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n   */\n\n  var looseMatching = function (value) {\n    return value.replace(regexpCfG, \"\").replace(regexpDashG, \"-\").replace(regexpZsG, \" \");\n  };\n  /**\n   * parse( value, properties )\n   *\n   * @value [String].\n   *\n   * @properties [Object] Parser properties is a reduced pre-processed cldr\n   * data set returned by numberParserProperties().\n   *\n   * Return the parsed Number (including Infinity) or NaN when value is invalid.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberParse = function (value, properties) {\n    var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix, suffix, tokenizer, valid; // Grammar:\n    // - Value <=           NaN | PositiveNumber | NegativeNumber\n    // - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\n    // - NegativeNumber <=  NegativePrefix NumberOrInf\n    // - NumberOrInf <=     Number | Inf\n\n    grammar = [[\"nan\"], [\"prefix\", \"infinity\", \"suffix\"], [\"prefix\", \"number\", \"suffix\"], [\"negativePrefix\", \"infinity\", \"negativeSuffix\"], [\"negativePrefix\", \"number\", \"negativeSuffix\"]];\n    invertedSymbolMap = properties[0];\n    invertedNuDigitsMap = properties[1] || {};\n    tokenizer = properties[2];\n    value = looseMatching(value);\n\n    function parse(type) {\n      return function (lexeme) {\n        // Reverse localized symbols and numbering system.\n        lexeme = lexeme.split(\"\").map(function (character) {\n          return invertedSymbolMap[character] || invertedNuDigitsMap[character] || character;\n        }).join(\"\");\n\n        switch (type) {\n          case \"infinity\":\n            number = Infinity;\n            break;\n\n          case \"nan\":\n            number = NaN;\n            break;\n\n          case \"number\":\n            // Remove grouping separators.\n            lexeme = lexeme.replace(/,/g, \"\");\n            number = +lexeme;\n            break;\n\n          case \"prefix\":\n          case \"negativePrefix\":\n            prefix = lexeme;\n            break;\n\n          case \"suffix\":\n            suffix = lexeme;\n            break;\n\n          case \"negativeSuffix\":\n            suffix = lexeme;\n            negative = true;\n            break;\n          // This should never be reached.\n\n          default:\n            throw new Error(\"Internal error\");\n        }\n\n        return \"\";\n      };\n    }\n\n    function tokenizeNParse(_value, grammar) {\n      return grammar.some(function (statement) {\n        var value = _value; // The whole grammar statement should be used (i.e., .every() return true) and value be\n        // entirely consumed (i.e., !value.length).\n\n        return statement.every(function (type) {\n          if (value.match(tokenizer[type]) === null) {\n            return false;\n          } // Consume and parse it.\n\n\n          value = value.replace(tokenizer[type], parse(type));\n          return true;\n        }) && !value.length;\n      });\n    }\n\n    valid = tokenizeNParse(value, grammar); // NaN\n\n    if (!valid || isNaN(number)) {\n      return NaN;\n    }\n\n    prefixNSuffix = \"\" + prefix + suffix; // Percent\n\n    if (prefixNSuffix.indexOf(\"%\") !== -1) {\n      number /= 100; // Per mille\n    } else if (prefixNSuffix.indexOf(\"\\u2030\") !== -1) {\n      number /= 1000;\n    } // Negative number\n\n\n    if (negative) {\n      number *= -1;\n    }\n\n    return number;\n  };\n\n  var numberParserFn = function (properties) {\n    return function numberParser(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeString(value, \"value\");\n      return numberParse(value, properties);\n    };\n  };\n  /**\n   * symbolMap( cldr )\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return the (localized symbol, pattern symbol) key value pair, eg. {\n   *   \"٫\": \".\",\n   *   \"٬\": \",\",\n   *   \"٪\": \"%\",\n   *   ...\n   * };\n   */\n\n\n  var numberSymbolInvertedMap = function (cldr) {\n    var symbol,\n        symbolMap = {};\n\n    for (symbol in numberSymbolName) {\n      symbolMap[numberSymbol(numberSymbolName[symbol], cldr)] = symbol;\n    }\n\n    return symbolMap;\n  };\n  /**\n   * objectMap( object, fn)\n   *\n   * - object\n   *\n   * - fn( pair ) => pair\n   */\n\n\n  var objectMap = function (object, fn) {\n    return Object.keys(object).map(function (key) {\n      return fn([key, object[key]]);\n    }).reduce(function (object, pair) {\n      object[pair[0]] = pair[1];\n      return object;\n    }, {});\n  };\n  /**\n   * parseProperties( pattern, cldr )\n   *\n   * @pattern [String] raw pattern for numbers.\n   *\n   * @cldr [Cldr instance].\n   *\n   * Return parser properties, used to feed parser function.\n   *\n   * TODO:\n   * - Scientific_notation;\n   * - Padding;\n   */\n\n\n  var numberParseProperties = function (pattern, cldr, options) {\n    var aux,\n        decimalSymbolRe,\n        digitsRe,\n        groupingSeparatorRe,\n        infinitySymbol,\n        invertedNuDigitsMap,\n        invertedSymbolMap,\n        maximumFractionDigits,\n        maximumSignificantDigits,\n        minimumSignificantDigits,\n        nanSymbol,\n        negativePrefix,\n        negativeSuffix,\n        nuDigitsMap,\n        numberTokenizer,\n        prefix,\n        primaryGroupingSize,\n        secondaryGroupingSize,\n        suffix,\n        symbolMap,\n        formatProperties = numberFormatProperties(pattern, cldr, options);\n    prefix = looseMatching(formatProperties[0]);\n    maximumFractionDigits = formatProperties[4];\n    minimumSignificantDigits = formatProperties[5];\n    maximumSignificantDigits = formatProperties[6];\n    primaryGroupingSize = formatProperties[8];\n    secondaryGroupingSize = formatProperties[9];\n    suffix = looseMatching(formatProperties[10]);\n    negativePrefix = looseMatching(formatProperties[13]);\n    negativeSuffix = looseMatching(formatProperties[14]);\n    infinitySymbol = looseMatching(formatProperties[16]);\n    nanSymbol = looseMatching(formatProperties[17]);\n    symbolMap = objectMap(formatProperties[18], function (pair) {\n      return [pair[0], looseMatching(pair[1])];\n    });\n    nuDigitsMap = formatProperties[19];\n    invertedSymbolMap = objectMap(numberSymbolInvertedMap(cldr), function (pair) {\n      return [looseMatching(pair[0]), pair[1]];\n    });\n    digitsRe = nuDigitsMap ? \"[\" + nuDigitsMap + \"]\" : \"\\\\d\";\n    groupingSeparatorRe = regexpEscape(symbolMap[\",\"]);\n    decimalSymbolRe = regexpEscape(symbolMap[\".\"]);\n\n    if (nuDigitsMap) {\n      invertedNuDigitsMap = nuDigitsMap.split(\"\").reduce(function (object, localizedDigit, i) {\n        object[localizedDigit] = String(i);\n        return object;\n      }, {});\n    }\n\n    aux = [prefix, suffix, negativePrefix, negativeSuffix].map(function (value) {\n      return value.replace(/('([^']|'')+'|'')|./g, function (character, literal) {\n        // Literals\n        if (literal) {\n          return removeLiteralQuotes(literal);\n        } // Symbols\n\n\n        character = character.replace(/[\\-+E%\\u2030]/, function (symbol) {\n          return symbolMap[symbol];\n        });\n        return character;\n      });\n    });\n    prefix = aux[0];\n    suffix = aux[1];\n    negativePrefix = aux[2];\n    negativeSuffix = aux[3]; // Number\n    //\n    // number_re =                       integer fraction?\n    //\n    // integer =                         digits | digits_using_grouping_separators\n    //\n    // fraction =                        regexp((.\\d+)?)\n    //\n    // digits =                          regexp(\\d+)\n    //\n    // digits_w_grouping_separators =    digits_w_1_grouping_separators |\n    //                                   digits_w_2_grouping_separators\n    //\n    // digits_w_1_grouping_separators =  regexp(\\d{1,3}(,\\d{3})+)\n    //\n    // digits_w_2_grouping_separators =  regexp(\\d{1,2}((,\\d{2})*(,\\d{3})))\n    // Integer part\n\n    numberTokenizer = digitsRe + \"+\"; // Grouping separators\n\n    if (primaryGroupingSize) {\n      if (secondaryGroupingSize) {\n        aux = digitsRe + \"{1,\" + secondaryGroupingSize + \"}((\" + groupingSeparatorRe + digitsRe + \"{\" + secondaryGroupingSize + \"})*(\" + groupingSeparatorRe + digitsRe + \"{\" + primaryGroupingSize + \"}))\";\n      } else {\n        aux = digitsRe + \"{1,\" + primaryGroupingSize + \"}(\" + groupingSeparatorRe + digitsRe + \"{\" + primaryGroupingSize + \"})+\";\n      }\n\n      numberTokenizer = \"(\" + aux + \"|\" + numberTokenizer + \")\";\n    } // Fraction part? Only included if 1 or 2.\n    // 1: Using significant digit format.\n    // 2: Using integer and fractional format && it has a maximumFractionDigits.\n\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits) ||\n    /* 1 */\n    maximumFractionDigits\n    /* 2 */\n    ) {\n        // 1: Handle trailing decimal separator, e.g., `\"1.\" => `1``.\n        aux = decimalSymbolRe + digitsRe + \"+\";\n        numberTokenizer = numberTokenizer + \"(\" + aux + \"|\" + decimalSymbolRe\n        /* 1 */\n        + \")?\" + // Handle non-padded decimals, e.g., `\".12\"` => `0.12` by making the integer part\n        // optional.\n        \"|(\" + numberTokenizer + \")?\" + aux;\n        numberTokenizer = \"(\" + numberTokenizer + \")\";\n      } // 0: @invertedSymbolMap [Object] Inverted symbol map.\n    // 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than\n    //    `latn`.\n    // 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.\n\n\n    return [invertedSymbolMap, invertedNuDigitsMap, {\n      infinity: new RegExp(\"^\" + regexpEscape(infinitySymbol)),\n      nan: new RegExp(\"^\" + regexpEscape(nanSymbol)),\n      negativePrefix: new RegExp(\"^\" + regexpEscape(negativePrefix)),\n      negativeSuffix: new RegExp(\"^\" + regexpEscape(negativeSuffix)),\n      number: new RegExp(\"^\" + numberTokenizer),\n      prefix: new RegExp(\"^\" + regexpEscape(prefix)),\n      suffix: new RegExp(\"^\" + regexpEscape(suffix))\n    }];\n  };\n  /**\n   * Pattern( style )\n   *\n   * @style [String] \"decimal\" (default) or \"percent\".\n   *\n   * @cldr [Cldr instance].\n   */\n\n\n  var numberPattern = function (style, cldr) {\n    if (style !== \"decimal\" && style !== \"percent\") {\n      throw new Error(\"Invalid style\");\n    }\n\n    return cldr.main([\"numbers\", style + \"Formats-numberSystem-\" + numberNumberingSystem(cldr), \"standard\"]);\n  };\n\n  function validateDigits(properties) {\n    var minimumIntegerDigits = properties[2],\n        minimumFractionDigits = properties[3],\n        maximumFractionDigits = properties[4],\n        minimumSignificantDigits = properties[5],\n        maximumSignificantDigits = properties[6]; // Validate significant digit format properties\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {\n      validateParameterRange(minimumSignificantDigits, \"minimumSignificantDigits\", 1, 21);\n      validateParameterRange(maximumSignificantDigits, \"maximumSignificantDigits\", minimumSignificantDigits, 21);\n    } else if (!isNaN(minimumSignificantDigits) || !isNaN(maximumSignificantDigits)) {\n      throw new Error(\"Neither or both the minimum and maximum significant digits must be \" + \"present\"); // Validate integer and fractional format\n    } else {\n      validateParameterRange(minimumIntegerDigits, \"minimumIntegerDigits\", 1, 21);\n      validateParameterRange(minimumFractionDigits, \"minimumFractionDigits\", 0, 20);\n      validateParameterRange(maximumFractionDigits, \"maximumFractionDigits\", minimumFractionDigits, 20);\n    }\n  }\n  /**\n   * .numberFormatter( [options] )\n   *\n   * @options [Object]:\n   * - style: [String] \"decimal\" (default) or \"percent\".\n   * - see also number/format options.\n   *\n   * Return a function that formats a number according to the given options and default/instance\n   * locale.\n   */\n\n\n  Globalize.numberFormatter = Globalize.prototype.numberFormatter = function (options) {\n    var args, cldr, fnArgs, pattern, properties, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n    cldr = this.cldr;\n    args = [options];\n    validateDefaultLocale(cldr);\n    cldr.on(\"get\", validateCldr);\n\n    if (options.raw) {\n      pattern = options.raw;\n    } else {\n      pattern = numberPattern(options.style || \"decimal\", cldr);\n    }\n\n    properties = numberFormatProperties(pattern, cldr, options);\n    fnArgs = [properties];\n    cldr.off(\"get\", validateCldr);\n    validateDigits(properties);\n\n    if (options.compact) {\n      fnArgs.push(this.pluralGenerator());\n    }\n\n    returnFn = numberFormatterFn.apply(null, fnArgs);\n    runtimeBind(args, cldr, returnFn, fnArgs);\n    return returnFn;\n  };\n  /**\n   * .numberParser( [options] )\n   *\n   * @options [Object]:\n   * - style: [String] \"decimal\" (default) or \"percent\".\n   *\n   * Return the number parser according to the default/instance locale.\n   */\n\n\n  Globalize.numberParser = Globalize.prototype.numberParser = function (options) {\n    var args, cldr, pattern, properties, returnFn;\n    validateParameterTypePlainObject(options, \"options\");\n    options = options || {};\n    cldr = this.cldr;\n    args = [options];\n    validateDefaultLocale(cldr);\n\n    if (options.compact) {\n      throw createErrorUnsupportedFeature({\n        feature: \"compact number parsing (not implemented)\"\n      });\n    }\n\n    cldr.on(\"get\", validateCldr);\n\n    if (options.raw) {\n      pattern = options.raw;\n    } else {\n      pattern = numberPattern(options.style || \"decimal\", cldr);\n    }\n\n    properties = numberParseProperties(pattern, cldr, options);\n    cldr.off(\"get\", validateCldr);\n    returnFn = numberParserFn(properties);\n    runtimeBind(args, cldr, returnFn, [properties]);\n    return returnFn;\n  };\n  /**\n   * .formatNumber( value [, options] )\n   *\n   * @value [Number] number to be formatted.\n   *\n   * @options [Object]: see number/format-properties.\n   *\n   * Format a number according to the given options and default/instance locale.\n   */\n\n\n  Globalize.formatNumber = Globalize.prototype.formatNumber = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeNumber(value, \"value\");\n    return this.numberFormatter(options)(value);\n  };\n  /**\n   * .parseNumber( value [, options] )\n   *\n   * @value [String]\n   *\n   * @options [Object]: See numberParser().\n   *\n   * Return the parsed Number (including Infinity) or NaN when value is invalid.\n   */\n\n\n  Globalize.parseNumber = Globalize.prototype.parseNumber = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeString(value, \"value\");\n    return this.numberParser(options)(value);\n  };\n  /**\n   * Optimization to avoid duplicating some internal functions across modules.\n   */\n\n\n  Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\n  Globalize._numberNumberingSystem = numberNumberingSystem;\n  Globalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;\n  Globalize._numberPattern = numberPattern;\n  Globalize._numberSymbol = numberSymbol;\n  Globalize._looseMatching = looseMatching;\n  Globalize._removeLiteralQuotes = removeLiteralQuotes;\n  Globalize._stringPad = stringPad;\n  Globalize._validateParameterTypeNumber = validateParameterTypeNumber;\n  Globalize._validateParameterTypeString = validateParameterTypeString;\n  return Globalize;\n});","map":null,"metadata":{},"sourceType":"script"}