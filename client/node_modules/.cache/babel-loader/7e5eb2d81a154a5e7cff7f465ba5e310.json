{"ast":null,"code":"/*!\n * Globalize v1.4.2\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2019-03-07T13:47Z\n */\n(function (root, factory) {\n  // UMD returnExports\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"cldr\", \"../globalize\", \"./number\", \"cldr/event\", \"cldr/supplemental\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"cldrjs\"), require(\"../globalize\"));\n  } else {\n    // Global\n    factory(root.Cldr, root.Globalize);\n  }\n})(this, function (Cldr, Globalize) {\n  var alwaysArray = Globalize._alwaysArray,\n      formatMessage = Globalize._formatMessage,\n      numberNumberingSystem = Globalize._numberNumberingSystem,\n      numberPattern = Globalize._numberPattern,\n      runtimeBind = Globalize._runtimeBind,\n      stringPad = Globalize._stringPad,\n      validateCldr = Globalize._validateCldr,\n      validateDefaultLocale = Globalize._validateDefaultLocale,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypeNumber = Globalize._validateParameterTypeNumber,\n      validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\n\n  var validateParameterTypeCurrency = function (value, name) {\n    validateParameterType(value, name, value === undefined || typeof value === \"string\" && /^[A-Za-z]{3}$/.test(value), \"3-letter currency code string as defined by ISO 4217\");\n  };\n  /**\n   * supplementalOverride( currency, pattern, cldr )\n   *\n   * Return pattern with fraction digits overriden by supplemental currency data.\n   */\n\n\n  var currencySupplementalOverride = function (currency, pattern, cldr) {\n    var digits,\n        fraction = \"\",\n        fractionData = cldr.supplemental([\"currencyData/fractions\", currency]) || cldr.supplemental(\"currencyData/fractions/DEFAULT\");\n    digits = +fractionData._digits;\n\n    if (digits) {\n      fraction = \".\" + stringPad(\"0\", digits).slice(0, -1) + fractionData._rounding;\n    }\n\n    return pattern.replace(/\\.(#+|0*[0-9]|0+[0-9]?)/g, fraction);\n  };\n\n  var objectFilter = function (object, testRe) {\n    var key,\n        copy = {};\n\n    for (key in object) {\n      if (testRe.test(key)) {\n        copy[key] = object[key];\n      }\n    }\n\n    return copy;\n  };\n\n  var currencyUnitPatterns = function (cldr) {\n    return objectFilter(cldr.main([\"numbers\", \"currencyFormats-numberSystem-\" + numberNumberingSystem(cldr)]), /^unitPattern/);\n  };\n  /**\n   * codeProperties( currency, cldr )\n   *\n   * Return number pattern with the appropriate currency code in as literal.\n   */\n\n\n  var currencyCodeProperties = function (currency, cldr) {\n    var pattern = numberPattern(\"decimal\", cldr); // The number of decimal places and the rounding for each currency is not locale-specific. Those\n    // values overridden by Supplemental Currency Data.\n\n    pattern = currencySupplementalOverride(currency, pattern, cldr);\n    return {\n      currency: currency,\n      pattern: pattern,\n      unitPatterns: currencyUnitPatterns(cldr)\n    };\n  };\n  /**\n   * nameFormat( formattedNumber, pluralForm, properties )\n   *\n   * Return the appropriate name form currency format.\n   */\n\n\n  var currencyNameFormat = function (formattedNumber, pluralForm, properties) {\n    var displayName,\n        unitPattern,\n        displayNames = properties.displayNames || {},\n        unitPatterns = properties.unitPatterns;\n    displayName = displayNames[\"displayName-count-\" + pluralForm] || displayNames[\"displayName-count-other\"] || displayNames.displayName || properties.currency;\n    unitPattern = unitPatterns[\"unitPattern-count-\" + pluralForm] || unitPatterns[\"unitPattern-count-other\"];\n    return formatMessage(unitPattern, [formattedNumber, displayName]);\n  };\n\n  var currencyFormatterFn = function (numberFormatter, pluralGenerator, properties) {\n    var fn; // Return formatter when style is \"code\" or \"name\".\n\n    if (pluralGenerator && properties) {\n      fn = function currencyFormatter(value) {\n        validateParameterPresence(value, \"value\");\n        validateParameterTypeNumber(value, \"value\");\n        return currencyNameFormat(numberFormatter(value), pluralGenerator(value), properties);\n      }; // Return formatter when style is \"symbol\" or \"accounting\".\n\n    } else {\n      fn = function currencyFormatter(value) {\n        return numberFormatter(value);\n      };\n    }\n\n    return fn;\n  };\n  /**\n   * nameProperties( currency, cldr )\n   *\n   * Return number pattern with the appropriate currency code in as literal.\n   */\n\n\n  var currencyNameProperties = function (currency, cldr) {\n    var properties = currencyCodeProperties(currency, cldr);\n    properties.displayNames = objectFilter(cldr.main([\"numbers/currencies\", currency]), /^displayName/);\n    return properties;\n  };\n  /**\n   * Unicode regular expression for: everything except math symbols, currency signs, dingbats, and\n   * box-drawing characters.\n   *\n   * Generated by:\n   *\n   * regenerate()\n   *   .addRange( 0x0, 0x10FFFF )\n   *   .remove( require( \"unicode-7.0.0/categories/S/symbols\" ) ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-7.0.0\n   */\n\n\n  var regexpNotS = /[\\0-#%-\\*,-;\\?-\\]_a-\\{\\}\\x7F-\\xA1\\xA7\\xAA\\xAB\\xAD\\xB2\\xB3\\xB5-\\xB7\\xB9-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376-\\u0383\\u0386-\\u03F5\\u03F7-\\u0481\\u0483-\\u058C\\u0590-\\u0605\\u0609\\u060A\\u060C\\u060D\\u0610-\\u06DD\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF-\\u07F5\\u07F7-\\u09F1\\u09F4-\\u09F9\\u09FC-\\u0AF0\\u0AF2-\\u0B6F\\u0B71-\\u0BF2\\u0BFB-\\u0C7E\\u0C80-\\u0D78\\u0D7A-\\u0E3E\\u0E40-\\u0F00\\u0F04-\\u0F12\\u0F14\\u0F18\\u0F19\\u0F20-\\u0F33\\u0F35\\u0F37\\u0F39-\\u0FBD\\u0FC6\\u0FCD\\u0FD0-\\u0FD4\\u0FD9-\\u109D\\u10A0-\\u138F\\u139A-\\u17DA\\u17DC-\\u193F\\u1941-\\u19DD\\u1A00-\\u1B60\\u1B6B-\\u1B73\\u1B7D-\\u1FBC\\u1FBE\\u1FC2-\\u1FCC\\u1FD0-\\u1FDC\\u1FE0-\\u1FEC\\u1FF0-\\u1FFC\\u1FFF-\\u2043\\u2045-\\u2051\\u2053-\\u2079\\u207D-\\u2089\\u208D-\\u209F\\u20BE-\\u20FF\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u218F\\u2308-\\u230B\\u2329\\u232A\\u23FB-\\u23FF\\u2427-\\u243F\\u244B-\\u249B\\u24EA-\\u24FF\\u2768-\\u2793\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2B74\\u2B75\\u2B96\\u2B97\\u2BBA-\\u2BBC\\u2BC9\\u2BD2-\\u2CE4\\u2CEB-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u3003\\u3005-\\u3011\\u3014-\\u301F\\u3021-\\u3035\\u3038-\\u303D\\u3040-\\u309A\\u309D-\\u318F\\u3192-\\u3195\\u31A0-\\u31BF\\u31E4-\\u31FF\\u321F-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u32FF\\u3400-\\u4DBF\\u4E00-\\uA48F\\uA4C7-\\uA6FF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA827\\uA82C-\\uA835\\uA83A-\\uAA76\\uAA7A-\\uAB5A\\uAB5C-\\uD7FF\\uDC00-\\uFB28\\uFB2A-\\uFBB1\\uFBC2-\\uFDFB\\uFDFE-\\uFE61\\uFE63\\uFE67\\uFE68\\uFE6A-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF1B\\uFF1F-\\uFF3D\\uFF3F\\uFF41-\\uFF5B\\uFF5D\\uFF5F-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]|\\uD800[\\uDC00-\\uDD36\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDD8D-\\uDD8F\\uDD9C-\\uDD9F\\uDDA1-\\uDDCF\\uDDFD-\\uDFFF]|[\\uD801\\uD803-\\uD819\\uD81B-\\uD82E\\uD830-\\uD833\\uD836-\\uD83A\\uD83F-\\uDBFF][\\uDC00-\\uDFFF]|\\uD802[\\uDC00-\\uDC76\\uDC79-\\uDEC7\\uDEC9-\\uDFFF]|\\uD81A[\\uDC00-\\uDF3B\\uDF40-\\uDF44\\uDF46-\\uDFFF]|\\uD82F[\\uDC00-\\uDC9B\\uDC9D-\\uDFFF]|\\uD834[\\uDCF6-\\uDCFF\\uDD27\\uDD28\\uDD65-\\uDD69\\uDD6D-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDDDE-\\uDDFF\\uDE42-\\uDE44\\uDE46-\\uDEFF\\uDF57-\\uDFFF]|\\uD835[\\uDC00-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFFF]|\\uD83B[\\uDC00-\\uDEEF\\uDEF2-\\uDFFF]|\\uD83C[\\uDC2C-\\uDC2F\\uDC94-\\uDC9F\\uDCAF\\uDCB0\\uDCC0\\uDCD0\\uDCF6-\\uDD0F\\uDD2F\\uDD6C-\\uDD6F\\uDD9B-\\uDDE5\\uDE03-\\uDE0F\\uDE3B-\\uDE3F\\uDE49-\\uDE4F\\uDE52-\\uDEFF\\uDF2D-\\uDF2F\\uDF7E\\uDF7F\\uDFCF-\\uDFD3\\uDFF8-\\uDFFF]|\\uD83D[\\uDCFF\\uDD4B-\\uDD4F\\uDD7A\\uDDA4\\uDE43\\uDE44\\uDED0-\\uDEDF\\uDEED-\\uDEEF\\uDEF4-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDFFF]|[\\uD800-\\uDBFF]/;\n  /**\n   * symbolProperties( currency, cldr )\n   *\n   * Return pattern replacing `¤` with the appropriate currency symbol literal.\n   */\n\n  var currencySymbolProperties = function (currency, cldr, options) {\n    var currencySpacing,\n        pattern,\n        symbol,\n        symbolEntries = [\"symbol\"],\n        regexp = {\n      \"[:digit:]\": /\\d/,\n      \"[:^S:]\": regexpNotS\n    }; // If options.symbolForm === \"narrow\" was passed, prepend it.\n\n    if (options.symbolForm === \"narrow\") {\n      symbolEntries.unshift(\"symbol-alt-narrow\");\n    }\n\n    symbolEntries.some(function (symbolEntry) {\n      return symbol = cldr.main([\"numbers/currencies\", currency, symbolEntry]);\n    });\n    currencySpacing = [\"beforeCurrency\", \"afterCurrency\"].map(function (position) {\n      return cldr.main([\"numbers\", \"currencyFormats-numberSystem-\" + numberNumberingSystem(cldr), \"currencySpacing\", position]);\n    });\n    pattern = cldr.main([\"numbers\", \"currencyFormats-numberSystem-\" + numberNumberingSystem(cldr), options.style === \"accounting\" ? \"accounting\" : \"standard\"]);\n    pattern = // The number of decimal places and the rounding for each currency is not locale-specific.\n    // Those values are overridden by Supplemental Currency Data.\n    currencySupplementalOverride(currency, pattern, cldr) // Replace \"¤\" (\\u00A4) with the appropriate symbol literal.\n    .split(\";\").map(function (pattern) {\n      return pattern.split(\"\\u00A4\").map(function (part, i) {\n        var currencyMatch = regexp[currencySpacing[i].currencyMatch],\n            surroundingMatch = regexp[currencySpacing[i].surroundingMatch],\n            insertBetween = \"\"; // For currencyMatch and surroundingMatch definitions, read [1].\n        // When i === 0, beforeCurrency is being handled. Otherwise, afterCurrency.\n        // 1: http://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies\n\n        currencyMatch = currencyMatch.test(symbol.charAt(i ? symbol.length - 1 : 0));\n        surroundingMatch = surroundingMatch.test(part.charAt(i ? 0 : part.length - 1).replace(/[#@,.]/g, \"0\"));\n\n        if (currencyMatch && part && surroundingMatch) {\n          insertBetween = currencySpacing[i].insertBetween;\n        }\n\n        return (i ? insertBetween : \"\") + part + (i ? \"\" : insertBetween);\n      }).join(\"'\" + symbol + \"'\");\n    }).join(\";\");\n    return {\n      pattern: pattern\n    };\n  };\n  /**\n   * objectOmit( object, keys )\n   *\n   * Return a copy of the object, filtered to omit the blacklisted key or array of keys.\n   */\n\n\n  var objectOmit = function (object, keys) {\n    var key,\n        copy = {};\n    keys = alwaysArray(keys);\n\n    for (key in object) {\n      if (keys.indexOf(key) === -1) {\n        copy[key] = object[key];\n      }\n    }\n\n    return copy;\n  };\n\n  function validateRequiredCldr(path, value) {\n    validateCldr(path, value, {\n      skip: [/numbers\\/currencies\\/[^/]+\\/symbol-alt-/, /supplemental\\/currencyData\\/fractions\\/[A-Za-z]{3}$/]\n    });\n  }\n  /**\n   * .currencyFormatter( currency [, options] )\n   *\n   * @currency [String] 3-letter currency code as defined by ISO 4217.\n   *\n   * @options [Object]:\n   * - style: [String] \"symbol\" (default), \"accounting\", \"code\" or \"name\".\n   * - see also number/format options.\n   *\n   * Return a function that formats a currency according to the given options and default/instance\n   * locale.\n   */\n\n\n  Globalize.currencyFormatter = Globalize.prototype.currencyFormatter = function (currency, options) {\n    var args, cldr, numberFormatter, pluralGenerator, properties, returnFn, style;\n    validateParameterPresence(currency, \"currency\");\n    validateParameterTypeCurrency(currency, \"currency\");\n    validateParameterTypePlainObject(options, \"options\");\n    cldr = this.cldr;\n    options = options || {};\n    args = [currency, options];\n    style = options.style || \"symbol\";\n    validateDefaultLocale(cldr); // Get properties given style (\"symbol\" default, \"code\" or \"name\").\n\n    cldr.on(\"get\", validateRequiredCldr);\n    properties = {\n      accounting: currencySymbolProperties,\n      code: currencyCodeProperties,\n      name: currencyNameProperties,\n      symbol: currencySymbolProperties\n    }[style](currency, cldr, options);\n    cldr.off(\"get\", validateRequiredCldr); // options = options minus style, plus raw pattern.\n\n    options = objectOmit(options, \"style\");\n    options.raw = properties.pattern; // Return formatter when style is \"symbol\" or \"accounting\".\n\n    if (style === \"symbol\" || style === \"accounting\") {\n      numberFormatter = this.numberFormatter(options);\n      returnFn = currencyFormatterFn(numberFormatter);\n      runtimeBind(args, cldr, returnFn, [numberFormatter]); // Return formatter when style is \"code\" or \"name\".\n    } else {\n      numberFormatter = this.numberFormatter(options);\n      pluralGenerator = this.pluralGenerator();\n      returnFn = currencyFormatterFn(numberFormatter, pluralGenerator, properties);\n      runtimeBind(args, cldr, returnFn, [numberFormatter, pluralGenerator, properties]);\n    }\n\n    return returnFn;\n  };\n  /**\n   * .currencyParser( currency [, options] )\n   *\n   * @currency [String] 3-letter currency code as defined by ISO 4217.\n   *\n   * @options [Object] see currencyFormatter.\n   *\n   * Return the currency parser according to the given options and the default/instance locale.\n   */\n\n\n  Globalize.currencyParser = Globalize.prototype.currencyParser = function ()\n  /* currency, options */\n  {// TODO implement parser.\n  };\n  /**\n   * .formatCurrency( value, currency [, options] )\n   *\n   * @value [Number] number to be formatted.\n   *\n   * @currency [String] 3-letter currency code as defined by ISO 4217.\n   *\n   * @options [Object] see currencyFormatter.\n   *\n   * Format a currency according to the given options and the default/instance locale.\n   */\n\n\n  Globalize.formatCurrency = Globalize.prototype.formatCurrency = function (value, currency, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeNumber(value, \"value\");\n    return this.currencyFormatter(currency, options)(value);\n  };\n  /**\n   * .parseCurrency( value, currency [, options] )\n   *\n   * @value [String]\n   *\n   * @currency [String] 3-letter currency code as defined by ISO 4217.\n   *\n   * @options [Object]: See currencyFormatter.\n   *\n   * Return the parsed currency or NaN when value is invalid.\n   */\n\n\n  Globalize.parseCurrency = Globalize.prototype.parseCurrency = function ()\n  /* value, currency, options */\n  {};\n\n  return Globalize;\n});","map":null,"metadata":{},"sourceType":"script"}